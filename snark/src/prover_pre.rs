use ark_poly::domain;
use ark_poly::{univariate::DensePolynomial as UnivariatePolynomial, DenseUVPolynomial, 
    EvaluationDomain, Evaluations, GeneralEvaluationDomain, Polynomial
};
use ark_std::{start_timer, end_timer};
use std::marker::PhantomData;
use std::time::Instant;
use ark_ec::pairing::Pairing;
use ark_ec::VariableBaseMSM;
use merlin::Transcript;
use my_ipa::{helper::interpolate_from_eval_domain, ipa::IPA};
use my_kzg::{biv_batch_kzg::BivBatchKZG, par_join_3, uni_batch_kzg::BatchKZG};
use ark_ff::{Zero, One, Field};
use de_network::{DeMultiNet as Net, DeNet, DeSerNet};
use rayon::{prelude::*, result};
use crate::indexer::{DeRowIndex, DeColIndex, NEvals, DeValEvals};
use crate::prover_nopre::NoPreProver;
use crate::par_join_4;
use my_kzg::uni_trivial_kzg::KZG;
use my_kzg::helper::{divide_by_x_minus_k, evaluate_one_lagrange, generate_powers, linear_combination_poly, linear_combination_poly_by_ref};
use my_kzg::uni_trivial_kzg::DeKZG;
use ark_serialize::{CanonicalSerialize, CanonicalDeserialize};
use std::mem::take;
use ark_ff::batch_inversion;
use my_kzg::helper::{generator_numerator_polynomial_no_repeat, interpolate_on_trivial_domain};
use my_kzg::transcript::ProofTranscript;

#[derive(Debug, Clone, CanonicalSerialize, CanonicalDeserialize)]
pub struct DeLowerAandBEvals<P: Pairing> {
    pub eval_la_pa_low: Vec<P::ScalarField>,
    pub eval_la_pa_high: Vec<P::ScalarField>,
    pub eval_la_pb_low: Vec<P::ScalarField>,
    pub eval_la_pb_high: Vec<P::ScalarField>,
    pub eval_la_pc_low: Vec<P::ScalarField>,
    pub eval_la_pc_high: Vec<P::ScalarField>,
    pub eval_lb_pa: Vec<P::ScalarField>,
    pub eval_lb_pb: Vec<P::ScalarField>,
    pub eval_lb_pc: Vec<P::ScalarField>,
}

#[derive(Debug, Clone, CanonicalSerialize, CanonicalDeserialize)]
pub struct DeLowerAandBPolys<P: Pairing> {
    pub la_pa_low: UnivariatePolynomial<P::ScalarField>,
    pub la_pa_high: UnivariatePolynomial<P::ScalarField>,
    pub la_pb_low: UnivariatePolynomial<P::ScalarField>,
    pub la_pb_high: UnivariatePolynomial<P::ScalarField>,
    pub la_pc_low: UnivariatePolynomial<P::ScalarField>,
    pub la_pc_high: UnivariatePolynomial<P::ScalarField>,
    pub lb_pa: UnivariatePolynomial<P::ScalarField>,
    pub lb_pb: UnivariatePolynomial<P::ScalarField>,
    pub lb_pc: UnivariatePolynomial<P::ScalarField>,
}

#[derive(Debug, Clone, CanonicalSerialize, CanonicalDeserialize)]
// The original data of col index vectors for pa, pb, pc
pub struct DeValPolys<P: Pairing> {
    pub val_pa: UnivariatePolynomial<P::ScalarField>,
    pub val_pb: UnivariatePolynomial<P::ScalarField>,
    pub val_pc: UnivariatePolynomial<P::ScalarField>,
}

#[derive(Debug, Clone, CanonicalSerialize, CanonicalDeserialize)]
// polynomials of A_low, A_high for rows, defined by r^{row_low} and r^{row_high}
pub struct DeAandTPolys<P: Pairing> {
    pub a_pa_low: UnivariatePolynomial<P::ScalarField>,
    pub a_pa_high: UnivariatePolynomial<P::ScalarField>,
    pub a_pb_low: UnivariatePolynomial<P::ScalarField>,
    pub a_pb_high: UnivariatePolynomial<P::ScalarField>,
    pub a_pc_low: UnivariatePolynomial<P::ScalarField>,
    pub a_pc_high: UnivariatePolynomial<P::ScalarField>,
    pub t_row_low: UnivariatePolynomial<P::ScalarField>,
    pub t_row_high: UnivariatePolynomial<P::ScalarField>,
}

#[derive(Debug, Clone, CanonicalSerialize, CanonicalDeserialize)]
// evaluations of r^{row_low} and r^{row_high}, used in lookup
pub struct DeAandTEvals<P: Pairing> {
    pub eval_a_pa_low: Vec<P::ScalarField>,
    pub eval_a_pa_high: Vec<P::ScalarField>,
    pub eval_a_pb_low: Vec<P::ScalarField>,
    pub eval_a_pb_high: Vec<P::ScalarField>,
    pub eval_a_pc_low: Vec<P::ScalarField>,
    pub eval_a_pc_high: Vec<P::ScalarField>,
    pub eval_t_row_low: Vec<P::ScalarField>,
    pub eval_t_row_high: Vec<P::ScalarField>,
}

#[derive(Debug, Clone, CanonicalSerialize, CanonicalDeserialize)]
// polynomials of B for columns, defined by alpha^{col}
pub struct DeBandTPolys<P: Pairing> {
    pub b_pa: UnivariatePolynomial<P::ScalarField>,
    pub b_pb: UnivariatePolynomial<P::ScalarField>,
    pub b_pc: UnivariatePolynomial<P::ScalarField>,
    pub t_col: UnivariatePolynomial<P::ScalarField>,
}

#[derive(Debug, Clone, CanonicalSerialize, CanonicalDeserialize)]
// evaluations of alpha^{col}, used in lookup
pub struct DeBandTEvals<P: Pairing> {
    pub eval_b_pa: Vec<P::ScalarField>,
    pub eval_b_pb: Vec<P::ScalarField>,
    pub eval_b_pc: Vec<P::ScalarField>,
    pub eval_t_col: Vec<P::ScalarField>,
}



#[derive(Debug, Clone, CanonicalSerialize, CanonicalDeserialize)]
// polynomials of n, generated by preprocessing
pub struct NPolys<P: Pairing> {
    pub row_pa_low: UnivariatePolynomial<P::ScalarField>,
    pub row_pa_high: UnivariatePolynomial<P::ScalarField>,
    pub row_pb_low: UnivariatePolynomial<P::ScalarField>,
    pub row_pb_high: UnivariatePolynomial<P::ScalarField>,
    pub row_pc_low: UnivariatePolynomial<P::ScalarField>,
    pub row_pc_high: UnivariatePolynomial<P::ScalarField>,
    pub col_pa: UnivariatePolynomial<P::ScalarField>,
    pub col_pb: UnivariatePolynomial<P::ScalarField>,
    pub col_pc: UnivariatePolynomial<P::ScalarField>,
}

pub struct PreProver<P: Pairing> {
    _pairing: PhantomData<P>,
}

#[inline]
fn slice_inbounds<T>(data: &[T], start: usize, end: usize) -> &[T] {
    if data.len() <= start {
        &[]
    } else if data.len() < end {
        &data[start..]
    } else {
        &data[start..end]
    }
}

impl<P: Pairing> PreProver<P> {

    pub fn compute_upper_a_t_polys_from_rows (
        // use x_domain for m, use m_domain for m prime
        m: usize,
        l: usize,
        x_domain: &GeneralEvaluationDomain<P::ScalarField>,
        m_domain: &GeneralEvaluationDomain<P::ScalarField>,
        row_index_vec: &DeRowIndex,
        r: &P::ScalarField,
    ) -> (DeAandTPolys<P>, DeAandTEvals<P>) {

        assert!(m.is_power_of_two());
        assert!(m_domain.size().is_power_of_two());
        assert_eq!(row_index_vec.row_pa_low.len(), m_domain.size());
        let sqrt_ml = ((m * l) as f64).sqrt() as usize;
        let r_pow = r.pow([sqrt_ml as u64]);

        let rows = [&row_index_vec.row_pa_low, &row_index_vec.row_pa_high, &row_index_vec.row_pb_low, &row_index_vec.row_pb_high,
            &row_index_vec.row_pc_low, &row_index_vec.row_pc_high];
        
        let ((mut polys, mut evals), (t_row_low, eval_t_row_low), (t_row_high, eval_t_row_high)) : ((Vec<_>, Vec<_>), _, _) = 
            par_join_3!(
            || rows.par_iter().enumerate().map(|(i, row)| {
                let base = if i % 2 == 1 {
                    r_pow
                } else {
                    *r
                };
                let evals : Vec<_> = row.par_iter().map(|eval| base.pow([*eval as u64])).collect();
                let poly = interpolate_from_eval_domain::<P>(evals.clone(), m_domain);
                (poly, evals)
            }).unzip(),
            || {
                let t_low_evals : Vec<_> = generate_powers(r, m);
                let t_row_low = interpolate_from_eval_domain::<P>(t_low_evals.clone(), x_domain);
                (t_row_low, t_low_evals)
            },
            || {
                let t_high_evals : Vec<_> = generate_powers(&r_pow, m);
                let t_row_high = interpolate_from_eval_domain::<P>(t_high_evals.clone(), x_domain);
                (t_row_high, t_high_evals)
            });
        
        (DeAandTPolys {a_pa_low: take(&mut polys[0]),
            a_pa_high: take(&mut polys[1]),
            a_pb_low: take(&mut polys[2]),
            a_pb_high: take(&mut polys[3]),
            a_pc_low: take(&mut polys[4]),
            a_pc_high: take(&mut polys[5]),
            t_row_low, t_row_high},
            DeAandTEvals {eval_a_pa_low: take(&mut evals[0]),
                eval_a_pa_high: take(&mut evals[1]),
                eval_a_pb_low: take(&mut evals[2]),
                eval_a_pb_high: take(&mut evals[3]),
                eval_a_pc_low: take(&mut evals[4]),
                eval_a_pc_high: take(&mut evals[5]),
                eval_t_row_low, eval_t_row_high})
    }

    pub fn commit_g1_h1_upper_a_t_polys (
        sub_prover_id: usize,
        sub_m_powers: &Vec<P::G1Affine>,
        x_srs: &Vec<P::G1Affine>,
        g1: &UnivariatePolynomial<P::ScalarField>, 
        h1: &UnivariatePolynomial<P::ScalarField>,
        upper_a_t_polys: &DeAandTPolys<P>,
    ) -> (Vec<P::G1>, Vec<P::G1>) {
        
        let step = start_timer!(|| "compute upper a");
        let set = upper_a_t_polys;
        let polys_upper_a = vec![&set.a_pa_low, &set.a_pa_high, &set.a_pb_low, 
            &set.a_pb_high, &set.a_pc_low, &set.a_pc_high];
        let coms_upper_a = BivBatchKZG::<P>::de_commit(&sub_m_powers, &polys_upper_a);
        let coms_upper_a = if Net::am_master() {
            coms_upper_a.unwrap()
        } else {
            Vec::new()
        };
        end_timer!(step);

        let step = start_timer!(|| "compute t");
        let size = x_srs.len() / Net::n_parties();
        let start = sub_prover_id * size;
        let end = start + size;
        let t_low_high = vec![&set.t_row_low, &set.t_row_high];
        let coeffs_t_low_high: Vec<Vec<P::ScalarField>> = t_low_high.par_iter().map(|poly| {
            let mut coeffs = poly.coeffs.to_vec();
            coeffs.resize(x_srs.len(), P::ScalarField::zero());
            coeffs
        } ).collect();
        let sub_coeffs_t_low_high: Vec<&[P::ScalarField]> = coeffs_t_low_high.par_iter().map(|coeff| {
            &coeff[start..end]
        }).collect();
        let sub_powers = &x_srs[start..end];
        let sub_coms_t_low_high: Vec<P::G1Affine> = sub_coeffs_t_low_high.into_par_iter().map(|sub_coeff| {
            P::G1MSM::msm_unchecked(sub_powers, &sub_coeff).into()
        }).collect();
        let sub_coms_t_low_high = Net::send_to_master(&sub_coms_t_low_high);
        let coms_t_low_high = if Net::am_master() {
            let sub_coms_t_low_high = sub_coms_t_low_high.unwrap();
            (0..2).into_par_iter()
                .map(|col_index| {
                    sub_coms_t_low_high.iter().map(|row| row[col_index])
                    .fold(P::G1MSM::zero(), |acc, x| acc + x)
                    .into().into()
                }).collect()
        } else {
            vec![P::G1::zero(); 2]
        };
        end_timer!(step);

        // commit g1, h1
        let step = start_timer!(|| "commit g1 h1");
        let g1_h1 = vec![g1, h1];
        let coms_g1_h1 = BatchKZG::<P>::commit(&x_srs, &g1_h1).unwrap();
        let coms_g1_h1_t: Vec<P::G1> = coms_g1_h1.iter().chain(coms_t_low_high.iter()).copied().collect();
        end_timer!(step);

        (coms_upper_a, coms_g1_h1_t)
    }

    pub fn compute_upper_b_t_polys_from_cols (
        // use x_domain for m, use m_domain for m prime
        m: usize,
        x_domain: &GeneralEvaluationDomain<P::ScalarField>,
        m_domain: &GeneralEvaluationDomain<P::ScalarField>,
        sub_col: &DeColIndex,
        alpha: &P::ScalarField,
    ) -> (DeBandTPolys<P>, DeBandTEvals<P>) {

        assert!(m.is_power_of_two());
        assert!(m_domain.size().is_power_of_two());
        assert_eq!(sub_col.col_pa.len(), m_domain.size());

        // compute B_pa, B_pb, B_pc
        let ((b_pa, eval_b_pa), (b_pb, eval_b_pb), (b_pc, eval_b_pc), (t_col, eval_t_col)) = par_join_4!(
            || {
                let evals_b_pa : Vec<_> = sub_col.col_pa.par_iter().map(|eval| alpha.pow([*eval as u64])).collect();
                let b_pa = interpolate_from_eval_domain::<P>(evals_b_pa.clone(), m_domain);
                (b_pa, evals_b_pa)
            }, 
            || {
                let evals_b_pb: Vec<_> = sub_col.col_pb.par_iter().map(|eval| alpha.pow([*eval as u64])).collect();
                let b_pb = interpolate_from_eval_domain::<P>(evals_b_pb.clone(), m_domain);
                (b_pb, evals_b_pb)
            }, 
            || {
                let evals_b_pc: Vec<_> = sub_col.col_pc.par_iter().map(|eval| alpha.pow([*eval as u64])).collect();
                let b_pc = interpolate_from_eval_domain::<P>(evals_b_pc.clone(), m_domain);
                (b_pc, evals_b_pc)
            },
            // REPEAT COMPUTE: all sub-provers compute t_col, only one suffices and this is repeated
            || {
                let t_col_evals : Vec<_> = generate_powers(alpha, m);
                let t_col = interpolate_from_eval_domain::<P>(t_col_evals.clone(), x_domain);
                (t_col, t_col_evals)
            }
        );

        (DeBandTPolys {b_pa, b_pb, b_pc, t_col},
            DeBandTEvals {eval_b_pa, eval_b_pb, eval_b_pc, eval_t_col})
    }

    pub fn commit_t_col (
        sub_prover_id: usize,
        x_srs: &[P::G1Affine],
        upper_b_t_polys: &DeBandTPolys<P>,
    ) -> P::G1 {
        let size = x_srs.len() / Net::n_parties();
        let start = sub_prover_id * size;
        let end = start + size;
        let t_col = &upper_b_t_polys.t_col;
        let mut coeff_t_col = t_col.to_vec();
        coeff_t_col.resize(x_srs.len(), P::ScalarField::zero());
        let sub_coeff_t_col = &coeff_t_col[start..end];
        let sub_powers = &x_srs[start..end];
        let sub_com_t_col: P::G1Affine = P::G1MSM::msm_unchecked(sub_powers, &sub_coeff_t_col).into();
        let sub_coms_t_col = Net::send_to_master(&sub_com_t_col);
        let com_t_col = if Net::am_master() {
            let sub_coms_t_col = sub_coms_t_col.unwrap();
            sub_coms_t_col.par_iter().sum()
        } else {
            P::G1::zero()
        };
        com_t_col
    }

    pub fn commit_upper_b_polys (
        sub_m_powers: &Vec<P::G1Affine>,
        upper_b_t_polys: &DeBandTPolys<P>,
    ) -> Vec<P::G1> {
        let polys_m_srs = vec![&upper_b_t_polys.b_pa, &upper_b_t_polys.b_pb, &upper_b_t_polys.b_pc];
        let coms_upper_b = BivBatchKZG::<P>::de_commit(&sub_m_powers, &polys_m_srs);

        if Net::am_master() {
            coms_upper_b.unwrap()
        } else {
            Vec::new()
        }
    }

    pub fn compute_pub_evals_alpha_beta (
        upper_a_t_evals: &DeAandTEvals<P>,
        upper_b_t_evals: &DeBandTEvals<P>,
        val_evals: &DeValEvals<P>,
        eval_beta: &P::ScalarField,
    ) -> Vec<P::ScalarField> {

        let (sum_pa, sum_pb, sum_pc): (P::ScalarField, P::ScalarField, P::ScalarField) = par_join_3!(
            || {
                let sum_pa: P::ScalarField = 
                        (&val_evals.evals_val_pa, &upper_a_t_evals.eval_a_pa_low, &upper_a_t_evals.eval_a_pa_high, &upper_b_t_evals.eval_b_pa)
                        .into_par_iter()
                        .map(|(a, b, c, d)| *a * *b * *c * *d).sum();
                let sum_pa = sum_pa * eval_beta;
                sum_pa
            }, 
            || {
                let sum_pb: P::ScalarField = 
                        (&val_evals.evals_val_pb, &upper_a_t_evals.eval_a_pb_low, &upper_a_t_evals.eval_a_pb_high, &upper_b_t_evals.eval_b_pb)
                        .into_par_iter()
                        .map(|(a, b, c, d)| *a * *b * *c * *d).sum();
                let sum_pb = sum_pb * eval_beta;
                sum_pb
            }, 
            || {
                let sum_pc: P::ScalarField = 
                        (&val_evals.evals_val_pc, &upper_a_t_evals.eval_a_pc_low, &upper_a_t_evals.eval_a_pc_high, &upper_b_t_evals.eval_b_pc)
                        .into_par_iter()
                        .map(|(a, b, c, d)| *a * *b * *c * *d).sum();
                let sum_pc = sum_pc * eval_beta;
                sum_pc
            }
        );

        // send sum to P0
        let sums_slice = Net::send_to_master(&(sum_pa, sum_pb, sum_pc));
        let (eval_pa_alpha_beta, eval_pb_alpha_beta, eval_pc_alpha_beta) = if Net::am_master() {
            let sums = sums_slice.unwrap();
            let (eval_pa_alpha_beta, eval_pb_alpha_beta, eval_pc_alpha_beta) = par_join_3!(
                || sums.par_iter().map(|slice| slice.0).sum(), 
                || sums.par_iter().map(|slice| slice.1).sum(), 
                || sums.par_iter().map(|slice| slice.2).sum()
            );
            (eval_pa_alpha_beta, eval_pb_alpha_beta, eval_pc_alpha_beta)
        } else {
            (P::ScalarField::zero(), P::ScalarField::zero(), P::ScalarField::zero())
        };

        vec![eval_pa_alpha_beta, eval_pb_alpha_beta, eval_pc_alpha_beta]
    }

    pub fn compute_sub_f1_and_f2 (
        lower_evals: &DeLowerAandBEvals<P>,
        a_t_evals: &DeAandTEvals<P>,
        b_t_evals: &DeBandTEvals<P>,
        n_evals: &NEvals<P>,
        m_domain: &GeneralEvaluationDomain<P::ScalarField>,
        x_domain: &GeneralEvaluationDomain<P::ScalarField>,
        gamma: &P::ScalarField,
        // v: &P::ScalarField,
        beta: &P::ScalarField,
    ) -> (Vec<UnivariatePolynomial<P::ScalarField>>, Vec<UnivariatePolynomial<P::ScalarField>>) {

        assert_eq!(m_domain.size(), a_t_evals.eval_a_pa_low.len());

        let w = x_domain.group_gen();

        let (polys_f2, polys_f1) = 
        rayon::join(
            || {
            let elements: Vec<P::ScalarField> = generate_powers(&w, x_domain.size());
    
            let mut denom_high : Vec<_> = a_t_evals.eval_t_row_high.par_iter()
            .zip(elements.par_iter())
            .map(|(t, y)| *gamma + *beta * y + t)
            .collect();
            batch_inversion(&mut denom_high);
            let mut denom_low : Vec<_> = a_t_evals.eval_t_row_low.par_iter()
            .zip(elements.par_iter())
            .map(|(t, y)| *gamma + *beta * y + t)
            .collect();
            batch_inversion(&mut denom_low);
            let mut denom_t_col : Vec<_> = b_t_evals.eval_t_col.par_iter()
            .zip(elements.par_iter())
            .map(|(t, y)| *gamma + *beta * y + t)
            .collect();
            batch_inversion(&mut denom_t_col);

            let numerators = [&n_evals.row_pa_low, &n_evals.row_pa_high, &n_evals.row_pb_low,
            &n_evals.row_pb_high, &n_evals.row_pc_low, &n_evals.row_pc_high, &n_evals.col_pa, &n_evals.col_pb, &n_evals.col_pc];
            let denominators = [&denom_low, &denom_high, &denom_low, &denom_high, &denom_low, &denom_high, &denom_t_col, &denom_t_col, &denom_t_col];
            numerators.par_iter().zip(denominators.par_iter())
                .map(|(numerator, denominator)| {
                    let evals = numerator.par_iter()
                        .zip(denominator.par_iter())
                        .map(|(n, d)| *n * d)
                        .collect::<Vec<_>>();
                    interpolate_from_eval_domain::<P>(evals, &x_domain)
                })
                .collect::<Vec<_>>()
        }, || {
            let lower = [&lower_evals.eval_la_pa_low, &lower_evals.eval_la_pa_high, &lower_evals.eval_la_pb_low,
                &lower_evals.eval_la_pb_high, &lower_evals.eval_la_pc_low, &lower_evals.eval_la_pc_high,
                &lower_evals.eval_lb_pa, &lower_evals.eval_lb_pb, &lower_evals.eval_lb_pc];
            let upper = [&a_t_evals.eval_a_pa_low, &a_t_evals.eval_a_pa_high, &a_t_evals.eval_a_pb_low,
                &a_t_evals.eval_a_pb_high, &a_t_evals.eval_a_pc_low, &a_t_evals.eval_a_pc_high, &b_t_evals.eval_b_pa, &b_t_evals.eval_b_pb,
                &b_t_evals.eval_b_pc];
            lower.par_iter().zip(upper.par_iter())
                .map(|(lower, upper)| {
                    let mut evals: Vec<P::ScalarField> = lower.par_iter()
                        .zip(upper.par_iter())
                        .map(|(lower, upper)| *gamma + *beta * lower + *upper)
                        .collect();
                    batch_inversion(&mut evals);
                    interpolate_from_eval_domain::<P>(evals, &m_domain)
                })
                .collect::<Vec<_>>()
        });

        (polys_f1, polys_f2)
    }

    pub fn compute_and_commit_q1 (
        m_srs: &[P::G1Affine],
        m_domain: &GeneralEvaluationDomain<P::ScalarField>,
        sub_polys_f1: &Vec<UnivariatePolynomial<P::ScalarField>>,
        upper_a_t_polys: &DeAandTPolys<P>,
        upper_b_t_polys: &DeBandTPolys<P>,
        lower_a_b_polys: &DeLowerAandBPolys<P>,
        v: &P::ScalarField,
        gamma: &P::ScalarField,
        beta: &P::ScalarField,
    ) -> (UnivariatePolynomial<P::ScalarField>, P::G1) {

        let step = start_timer!(|| "compute q1");
        let m_prime = m_domain.size();
        let domain = <GeneralEvaluationDomain<P::ScalarField> as EvaluationDomain<P::ScalarField>>::new(2 * m_prime).unwrap();
        let f1_evals: Vec<Vec<P::ScalarField>> = sub_polys_f1.par_iter().map(|poly| poly.evaluate_over_domain_by_ref(domain).evals).collect();
        let lower_polys = vec![&lower_a_b_polys.la_pa_low, &lower_a_b_polys.la_pa_high, &lower_a_b_polys.la_pb_low, &lower_a_b_polys.la_pb_high,
            &lower_a_b_polys.la_pc_low, &lower_a_b_polys.la_pc_high, &lower_a_b_polys.lb_pa, &lower_a_b_polys.lb_pb, &lower_a_b_polys.lb_pc];
        let upper_polys = vec![&upper_a_t_polys.a_pa_low, &upper_a_t_polys.a_pa_high, &upper_a_t_polys.a_pb_low,
            &upper_a_t_polys.a_pb_high, &upper_a_t_polys.a_pc_low, &upper_a_t_polys.a_pc_high,
            &upper_b_t_polys.b_pa, &upper_b_t_polys.b_pb, &upper_b_t_polys.b_pc];

        let mut linear_factors = generate_powers(v, 9);
        let multiplier = (domain.group_gen().pow([m_domain.size() as u64]) - P::ScalarField::one()).inverse().unwrap();

        linear_factors.iter_mut()
            .for_each(|factor| {
                *factor *= multiplier;
            });
    
        let virtual_polys: Vec<UnivariatePolynomial<P::ScalarField>> = (&lower_polys, &upper_polys, &linear_factors)
            .into_par_iter()
            .map(|(lower, upper, factor)| {
                let mut poly = (*lower * (*beta * factor)) + (*upper * *factor);
                poly.coeffs[0] += *gamma * *factor;
                poly
            })
            .collect();
        let virtual_evals: Vec<Vec<P::ScalarField>> = virtual_polys.par_iter().map(|poly| poly.evaluate_over_domain_by_ref(domain).evals).collect();

        let evals_target: Vec<P::ScalarField> = (0..domain.size() / 2).into_par_iter()
            .map(|k| {
                let col_index = 2 * k + 1;
                f1_evals.par_iter()
                    .zip(virtual_evals.par_iter())
                    .map(|(f1_eval, aux_eval)|{
                        f1_eval[col_index] * aux_eval[col_index]
                    })
                    .sum::<P::ScalarField>()
            })
            .collect();
        // We are interpolating a polynomial q', and q_1(x) = q'(x / omega) where omega is the gen of the 2x domain
        let mut sub_poly_q1 = interpolate_from_eval_domain::<P>(evals_target, &m_domain);
        let mut elem = domain.group_gen_inv();
        sub_poly_q1.coeffs.iter_mut()
            .skip(1)
            .for_each(|coeff| {
                *coeff *= elem;
                elem *= domain.group_gen_inv();
            });
        sub_poly_q1.coeffs[0] -= linear_factors.iter().sum::<P::ScalarField>();
        end_timer!(step);

        let step = start_timer!(|| "commit q1");
        let sub_com_q1 = KZG::<P>::commit(&m_srs, &sub_poly_q1).unwrap();
        let com_q1 = Net::send_to_master(&sub_com_q1);
        let com_q1 = if Net::am_master() {
            com_q1.unwrap().par_iter().sum()
        } else {
            P::G1::zero()
        };
        end_timer!(step);
        (sub_poly_q1, com_q1)
    }

    pub fn open_q1 (
        m_srs: &[P::G1Affine],
        sub_poly_q1: &UnivariatePolynomial<P::ScalarField>,
        delta: &P::ScalarField
    ) -> (P::ScalarField, P::G1) {
        DeKZG::<P>::de_open_with_eval(&m_srs, &sub_poly_q1, &delta)
    }

    // only P_0 works
    pub fn compute_and_commit_g5_h5 (
        y_srs: &Vec<P::G1Affine>,
        sub_polys_f1: &Vec<UnivariatePolynomial<P::ScalarField>>,
        upper_total_evals: &Vec<Vec<P::ScalarField>>,
        lower_evals: &Vec<P::ScalarField>,
        y_domain: &GeneralEvaluationDomain<P::ScalarField>,
        delta: &P::ScalarField,
        beta: &P::ScalarField,
        gamma: &P::ScalarField,
        v: &P::ScalarField,
        u4: &P::ScalarField,
        // for test
        eval_q1: &P::ScalarField,
        m_domain: &GeneralEvaluationDomain<P::ScalarField>
    ) -> (Vec<UnivariatePolynomial<P::ScalarField>>, Vec<P::G1>) {
        // send lower evals to master
        // compute f1 evals at delta
        let f1_evals: Vec<P::ScalarField> = sub_polys_f1.par_iter().map(|poly| poly.evaluate(delta)).collect();
        let lower_f1_evals = Net::send_to_master(&(lower_evals.clone(), f1_evals));

        let poly_one = UnivariatePolynomial::from_coefficients_vec(vec![P::ScalarField::one()]);

        if Net::am_master() {
            let lower_f1_evals = lower_f1_evals.unwrap();
            let lower_total_evals: Vec<Vec<P::ScalarField>> = lower_f1_evals.clone().into_par_iter().map(|eval| eval.0).collect();
            let f1_total_evals: Vec<Vec<P::ScalarField>> = lower_f1_evals.into_par_iter().map(|eval| eval.1).collect();
            let (upper_row_pa_low_delta, upper_row_pa_high_delta, upper_row_pb_low_delta): (Vec<P::ScalarField>, Vec<P::ScalarField>, Vec<P::ScalarField>) = par_join_3!(
                || upper_total_evals.par_iter().map(|evals| evals[3]).collect(),
                || upper_total_evals.par_iter().map(|evals| evals[4]).collect(),
                || upper_total_evals.par_iter().map(|evals| evals[5]).collect()
            );
            let (upper_row_pb_high_delta, upper_row_pc_low_delta, upper_row_pc_high_delta): (Vec<P::ScalarField>, Vec<P::ScalarField>, Vec<P::ScalarField>) = par_join_3!(
                || upper_total_evals.par_iter().map(|evals| evals[6]).collect(),
                || upper_total_evals.par_iter().map(|evals| evals[7]).collect(),
                || upper_total_evals.par_iter().map(|evals| evals[8]).collect()
            );
            let (upper_col_pa_delta, upper_col_pb_delta, upper_col_pc_delta): (Vec<P::ScalarField>, Vec<P::ScalarField>, Vec<P::ScalarField>) = par_join_3!(
                || upper_total_evals.par_iter().map(|evals| evals[9]).collect(),
                || upper_total_evals.par_iter().map(|evals| evals[10]).collect(),
                || upper_total_evals.par_iter().map(|evals| evals[11]).collect()
            );
            // lower evals: 
            let (lower_row_pa_low_delta, lower_row_pa_high_delta, lower_row_pb_low_delta): (Vec<P::ScalarField>, Vec<P::ScalarField>, Vec<P::ScalarField>) = par_join_3!(
                || lower_total_evals.par_iter().map(|evals| evals[0]).collect(),
                || lower_total_evals.par_iter().map(|evals| evals[1]).collect(),
                || lower_total_evals.par_iter().map(|evals| evals[2]).collect()
            );
            let (lower_row_pb_high_delta, lower_row_pc_low_delta, lower_row_pc_high_delta): (Vec<P::ScalarField>, Vec<P::ScalarField>, Vec<P::ScalarField>) = par_join_3!(
                || lower_total_evals.par_iter().map(|evals| evals[3]).collect(),
                || lower_total_evals.par_iter().map(|evals| evals[4]).collect(),
                || lower_total_evals.par_iter().map(|evals| evals[5]).collect()
            );
            let (lower_col_pa_delta, lower_col_pb_delta, lower_col_pc_delta): (Vec<P::ScalarField>, Vec<P::ScalarField>, Vec<P::ScalarField>) = par_join_3!(
                || lower_total_evals.par_iter().map(|evals| evals[6]).collect(),
                || lower_total_evals.par_iter().map(|evals| evals[7]).collect(),
                || lower_total_evals.par_iter().map(|evals| evals[8]).collect()
            );
            // f1 evals:
            let (f1_row_pa_low, f1_row_pa_high, f1_row_pb_low) = par_join_3!(
                || {
                    let evals = f1_total_evals.par_iter().map(|evals| evals[0]).collect();
                    interpolate_from_eval_domain::<P>(evals, y_domain)
                }, 
                || {
                    let evals = f1_total_evals.par_iter().map(|evals| evals[1]).collect();
                    interpolate_from_eval_domain::<P>(evals, y_domain)
                }, 
                || {
                    let evals = f1_total_evals.par_iter().map(|evals| evals[2]).collect();
                    interpolate_from_eval_domain::<P>(evals, y_domain)
                }
            );
            let (f1_row_pb_high, f1_row_pc_low, f1_row_pc_high) = par_join_3!(
                || {
                    let evals = f1_total_evals.par_iter().map(|evals| evals[3]).collect();
                    interpolate_from_eval_domain::<P>(evals, y_domain)
                }, 
                || {
                    let evals = f1_total_evals.par_iter().map(|evals| evals[4]).collect();
                    interpolate_from_eval_domain::<P>(evals, y_domain)
                }, 
                || {
                    let evals = f1_total_evals.par_iter().map(|evals| evals[5]).collect();
                    interpolate_from_eval_domain::<P>(evals, y_domain)
                }
            );
            let (f1_col_pa, f1_col_pb, f1_col_pc) = par_join_3!(
                || {
                    let evals = f1_total_evals.par_iter().map(|evals| evals[6]).collect();
                    interpolate_from_eval_domain::<P>(evals, y_domain)
                }, 
                || {
                    let evals = f1_total_evals.par_iter().map(|evals| evals[7]).collect();
                    interpolate_from_eval_domain::<P>(evals, y_domain)
                }, 
                || {
                    let evals = f1_total_evals.par_iter().map(|evals| evals[8]).collect();
                    interpolate_from_eval_domain::<P>(evals, y_domain)
                }
            );
            // target polynomials
            let (poly_row_pa_low, poly_row_pa_high, poly_row_pb_low) = par_join_3!(
                || {
                    let right_evals = upper_row_pa_low_delta.par_iter().zip(lower_row_pa_low_delta.par_iter())
                        .map(|(a, b)| *a + *b * *beta + gamma).collect();
                    let right_poly = interpolate_from_eval_domain::<P>(right_evals, y_domain);
                    &(&f1_row_pa_low * &right_poly) - &poly_one
                }, 
                || {
                    let right_evals = upper_row_pa_high_delta.par_iter().zip(lower_row_pa_high_delta.par_iter())
                        .map(|(a, b)| *a + *b * *beta + gamma).collect();
                    let right_poly = interpolate_from_eval_domain::<P>(right_evals, y_domain);
                    &(&f1_row_pa_high * &right_poly) - &poly_one
                }, 
                || {
                    let right_evals = upper_row_pb_low_delta.par_iter().zip(lower_row_pb_low_delta.par_iter())
                        .map(|(a, b)| *a + *b * *beta + gamma).collect();
                    let right_poly = interpolate_from_eval_domain::<P>(right_evals, y_domain);
                    &(&f1_row_pb_low * &right_poly) - &poly_one
                }
            );
            let (poly_row_pb_high, poly_row_pc_low, poly_row_pc_high) = par_join_3!(
                || {
                    let right_evals = upper_row_pb_high_delta.par_iter().zip(lower_row_pb_high_delta.par_iter())
                        .map(|(a, b)| *a + *b * *beta + gamma).collect();
                    let right_poly = interpolate_from_eval_domain::<P>(right_evals, y_domain);
                    &(&f1_row_pb_high * &right_poly) - &poly_one
                }, 
                || {
                    let right_evals = upper_row_pc_low_delta.par_iter().zip(lower_row_pc_low_delta.par_iter())
                        .map(|(a, b)| *a + *b * *beta + gamma).collect();
                    let right_poly = interpolate_from_eval_domain::<P>(right_evals, y_domain);
                    &(&f1_row_pc_low * &right_poly) - &poly_one
                }, 
                || {
                    let right_evals = upper_row_pc_high_delta.par_iter().zip(lower_row_pc_high_delta.par_iter())
                        .map(|(a, b)| *a + *b * *beta + gamma).collect();
                    let right_poly = interpolate_from_eval_domain::<P>(right_evals, y_domain);
                    &(&f1_row_pc_high * &right_poly) - &poly_one
                }
            );
            let (poly_col_pa, poly_col_pb, poly_col_pc) = par_join_3!(
                || {
                    let right_evals = upper_col_pa_delta.par_iter().zip(lower_col_pa_delta.par_iter())
                        .map(|(a, b)| *a + *b * *beta + gamma).collect();
                    let right_poly = interpolate_from_eval_domain::<P>(right_evals, y_domain);
                    &(&f1_col_pa * &right_poly) - &poly_one
                }, 
                || {
                    let right_evals = upper_col_pb_delta.par_iter().zip(lower_col_pb_delta.par_iter())
                        .map(|(a, b)| *a + *b * *beta + gamma).collect();
                    let right_poly = interpolate_from_eval_domain::<P>(right_evals, y_domain);
                    &(&f1_col_pb * &right_poly) - &poly_one
                }, 
                || {
                    let right_evals = upper_col_pc_delta.par_iter().zip(lower_col_pc_delta.par_iter())
                        .map(|(a, b)| *a + *b * *beta + gamma).collect();
                    let right_poly = interpolate_from_eval_domain::<P>(right_evals, y_domain);
                    &(&f1_col_pc * &right_poly) - &poly_one
                }
            );
            let polys_vec = vec![poly_row_pa_low, poly_row_pa_high, poly_row_pb_low, poly_row_pb_high, poly_row_pc_low, poly_row_pc_high,
                poly_col_pa, poly_col_pb, poly_col_pc];
            let poly_target = linear_combination_poly::<P>(&polys_vec, &v);
            let sum = IPA::<P>::get_sum_on_domain(&poly_target, &y_domain);
            assert_eq!(sum, *eval_q1 * m_domain.evaluate_vanishing_polynomial(*delta));

            let (poly_g5, poly_h5) = IPA::<P>::get_g_mul_u_and_h(&poly_target, &u4, &y_domain);
            let polys_g5_h5 = vec![poly_g5, poly_h5];
            let eval_vec = polys_g5_h5.par_iter().map(|poly| poly.evaluate_over_domain_by_ref(*y_domain).evals).collect();
            let coms_g5_h5 = BatchKZG::<P>::commit_lagrange(&y_srs, &eval_vec).unwrap();

            (polys_g5_h5, coms_g5_h5)
        } else {
            (vec![UnivariatePolynomial::zero(); 2], vec![P::G1::zero(); 2])
        }
    } 

    pub fn commit_f1_f2 (
        sub_prover_id: usize,
        sub_m_powers: &Vec<P::G1Affine>,
        x_srs: &Vec<P::G1Affine>,
        sub_polys_f1: &Vec<UnivariatePolynomial<P::ScalarField>>,
        polys_f2: &Vec<UnivariatePolynomial<P::ScalarField>>,
    ) -> (Vec<P::G1>, Vec<P::G1>) {
        let coms_f1 = BivBatchKZG::<P>::de_commit(&sub_m_powers, &sub_polys_f1.iter().collect::<Vec<_>>());
    
        let size = x_srs.len() / Net::n_parties();
        let start = sub_prover_id * size;
        let end = start + size;

        let sub_coeffs_f2: Vec<&[P::ScalarField]> = polys_f2.iter().map(|poly| {
            slice_inbounds(&poly.coeffs, start, end)
        }).collect();
        let sub_powers = &x_srs[start..end];
        let sub_coms_f2: Vec<P::G1Affine> = sub_coeffs_f2.into_par_iter().map(|sub_coeff| {
            P::G1MSM::msm_unchecked(sub_powers, &sub_coeff).into()
        }).collect();
        let sub_coms_f2 = Net::send_to_master(&sub_coms_f2);
        let coms_f2 = if Net::am_master() {
            let sub_coms_f2 = sub_coms_f2.unwrap();
            (0..9).into_par_iter()
                .map(|col_index| {
                    sub_coms_f2.iter().map(|row| row[col_index])
                    .fold(P::G1MSM::zero(), |acc, x| acc + x)
                    .into().into()
                }).collect()
        } else {
            vec![P::G1::zero(); 9]
        };

        let coms_f1 = if Net::am_master() {
            let coms_f1 = coms_f1.unwrap();
            coms_f1
        } else {
            vec![P::G1::zero(); 9]
        };

        (coms_f1, coms_f2)
    }

    // g3, h3 are de-polys
    pub fn compute_g3_h3 (
        val_polys: &DeValPolys<P>,
        upper_a_t_polys: &DeAandTPolys<P>,
        upper_b_t_polys: &DeBandTPolys<P>,
        m_domain: &GeneralEvaluationDomain<P::ScalarField>,
        eval_beta: &P::ScalarField,
        w: &P::ScalarField,
        u3: &P::ScalarField,
    ) -> Vec<UnivariatePolynomial<P::ScalarField>> {
        let m_prime = m_domain.size();
        let domain_4m = <GeneralEvaluationDomain<P::ScalarField> as EvaluationDomain<P::ScalarField>>::new(4 * m_prime).unwrap();
        
        // Multiply this factor first to save 3m multiplication compared to doing it when the domain is enlarged
        let mut pa = val_polys.val_pa.clone();
        pa.coeffs.par_iter_mut().for_each(|x| *x *= eval_beta);

        let polys_first = vec![&pa, &upper_a_t_polys.a_pa_high, &upper_a_t_polys.a_pa_low, &upper_b_t_polys.b_pa];
        
        let mut pb = val_polys.val_pb.clone();
        let factor = *eval_beta * w;
        pb.coeffs.par_iter_mut().for_each(|x| *x *= factor);

        let polys_second = vec![&pb, &upper_a_t_polys.a_pb_high, &upper_a_t_polys.a_pb_low, &upper_b_t_polys.b_pb];

        let mut pc = val_polys.val_pc.clone();
        let factor = *eval_beta * w.square();
        pc.coeffs.par_iter_mut().for_each(|x| *x *= factor);

        let polys_third = vec![&pc, &upper_a_t_polys.a_pc_high, &upper_a_t_polys.a_pc_low, &upper_b_t_polys.b_pc];

        let evals: Vec<Vec<P::ScalarField>> = polys_first.par_iter()
            .chain(polys_second.par_iter())
            .chain(polys_third.par_iter())
            .map(|&f| f.evaluate_over_domain_by_ref(domain_4m).evals).collect();

        let evals_target = (0..evals[0].len())
            .into_par_iter()
            .map(|i| {
                evals[0][i] * evals[1][i] * evals[2][i] * evals[3][i] +
                evals[4][i] * evals[5][i] * evals[6][i] * evals[7][i] +
                evals[8][i] * evals[9][i] * evals[10][i] * evals[11][i]
            })
            .collect::<Vec<_>>();
        let evals_domain_target = Evaluations::<P::ScalarField>::from_vec_and_domain(evals_target, domain_4m);
        let poly_target = evals_domain_target.interpolate();

        // compute poly_g3 and poly_h
        let (poly_g3, mut poly_h) = IPA::<P>::get_g_mul_u_and_h(&poly_target, &u3, &m_domain);
        let mut coeffs_h3 = take(&mut poly_h.coeffs);
        if coeffs_h3.len() <= 2 * m_prime {
            coeffs_h3.resize( 2 * m_prime + 1, P::ScalarField::zero());
            println!("Pad h3 degree");
        }
        assert!(coeffs_h3.len() > 2 * m_prime);
        assert!(coeffs_h3.len() <= 3 * m_prime);

        // Split coeffs into three portions
        let coeffs_h3_mid = coeffs_h3[m_prime..(2 * m_prime)].to_vec();
        let coeffs_h3_high = coeffs_h3[(2 * m_prime) ..].to_vec();
        coeffs_h3.truncate(m_prime);

        let (poly_h3_low, poly_h3_mid, poly_h3_high): (UnivariatePolynomial<P::ScalarField>, UnivariatePolynomial<P::ScalarField>, UnivariatePolynomial<P::ScalarField>) = (
            UnivariatePolynomial::from_coefficients_vec(coeffs_h3), 
            UnivariatePolynomial::from_coefficients_vec(coeffs_h3_mid),
            UnivariatePolynomial::from_coefficients_vec(coeffs_h3_high)
        );

        let polys_g3_h3 = vec![poly_g3, poly_h3_low, poly_h3_mid, poly_h3_high];

        polys_g3_h3
    }

    pub fn commit_g3_h3 (
        m_srs: &Vec<P::G1Affine>,
        polys_g3_h3: &Vec<UnivariatePolynomial<P::ScalarField>>,
    ) -> Vec<P::G1> {
        let sub_com_g3_h3 = BatchKZG::<P>::commit(&m_srs, &polys_g3_h3.iter().collect::<Vec<_>>()).unwrap();

        let sub_com_g3_h3 = Net::send_to_master(&sub_com_g3_h3);
        let coms_g3_h3 = if Net::am_master() {
            let sub_coms_g3_h3 = sub_com_g3_h3.unwrap();
            assert_eq!(sub_coms_g3_h3[0].len(), 4);
            vec![sub_coms_g3_h3.par_iter().map(|coms| coms[0]).sum(), sub_coms_g3_h3.par_iter().map(|coms| coms[1]).sum(), 
            sub_coms_g3_h3.par_iter().map(|coms| coms[2]).sum(), sub_coms_g3_h3.par_iter().map(|coms| coms[3]).sum()]
        } else {
            Vec::new()
        };

        coms_g3_h3
    }

    // compute de-evals of upper and lower polys at delta
    pub fn compute_evals_at_delta_beta_and_g3_h3_proofs (
        m_srs: &[P::G1Affine],
        val_polys: &DeValPolys<P>,
        upper_a_t_polys: &DeAandTPolys<P>,
        upper_b_t_polys: &DeBandTPolys<P>,
        lower_a_b_polys: &DeLowerAandBPolys<P>,
        eval_beta: &P::ScalarField,
        polys_g3_h3: &Vec<UnivariatePolynomial<P::ScalarField>>,
        delta: &P::ScalarField,
        gamma: &P::ScalarField,
    ) -> (Vec<P::ScalarField>, Vec<P::ScalarField>, Vec<P::ScalarField>, P::G1) {
        // evaluate upper polys Alow, Ahigh, B plus L(beta) evaluations on delta and beta
        par_join_4!(
            || {
                let polys = vec![&val_polys.val_pa, &val_polys.val_pb, &val_polys.val_pc, &upper_a_t_polys.a_pa_low,
                &upper_a_t_polys.a_pa_high, &upper_a_t_polys.a_pb_low, &upper_a_t_polys.a_pb_high, &upper_a_t_polys.a_pc_low,
                &upper_a_t_polys.a_pc_high, &upper_b_t_polys.b_pa, &upper_b_t_polys.b_pb, &upper_b_t_polys.b_pc];
                let mut evals = polys.par_iter().map(|&poly| poly.evaluate(&delta)).collect::<Vec<_>>();
                evals.push(*eval_beta);
                evals
            }, 
            || {
                let polys = vec![&lower_a_b_polys.la_pa_low, &lower_a_b_polys.la_pa_high, &lower_a_b_polys.la_pb_low,
                &lower_a_b_polys.la_pb_high, &lower_a_b_polys.la_pc_low, &lower_a_b_polys.la_pc_high,
                &lower_a_b_polys.lb_pa, &lower_a_b_polys.lb_pb, &lower_a_b_polys.lb_pc];
                polys.par_iter().map(|&poly| poly.evaluate(&delta)).collect()
            },
            || {
                polys_g3_h3.par_iter().map(|poly| poly.evaluate(&delta)).collect()
            },
            || {
                 BatchKZG::<P>::open(&m_srs, &polys_g3_h3.iter().collect::<Vec<_>>(), &delta, &gamma).unwrap()
            }
        )
    }

    pub fn send_evals_at_delta_beta_and_g3_h3_proofs (
        upper_evals: &Vec<P::ScalarField>, 
        g3_h3_evals: &Vec<P::ScalarField>,
        proof_g3_h3: &P::G1,
    ) -> (Vec<Vec<P::ScalarField>>, Vec<P::ScalarField>, P::G1) {
        let evals = Net::send_to_master(&(upper_evals.clone(), g3_h3_evals.clone(), proof_g3_h3.clone()));

        let (upper_total_evals, evals_g3_h3, proof_g3_h3) = if Net::am_master() {
            let evals = evals.unwrap();
            let upper_evals = evals.par_iter().map(|(a, _, _)| a.clone()).collect();
            let g3_h3_evals: Vec<Vec<P::ScalarField>> = evals.par_iter().map(|(_, b, _)| b.clone()).collect();
            let (eval_g3, eval_h3_low, eval_h3_mid, eval_h3_high): (P::ScalarField, P::ScalarField, P::ScalarField, P::ScalarField) = par_join_4!(
                || g3_h3_evals.par_iter().map(|eval| eval[0]).sum(),
                || g3_h3_evals.par_iter().map(|eval| eval[1]).sum(),
                || g3_h3_evals.par_iter().map(|eval| eval[2]).sum(),
                || g3_h3_evals.par_iter().map(|eval| eval[3]).sum()
            );
            let evals_g3_h3 = vec![eval_g3, eval_h3_low, eval_h3_mid, eval_h3_high];
            let proof_g3_h3 = evals.par_iter().map(|(_, _, c)| c.clone()).sum();
            (upper_evals, evals_g3_h3, proof_g3_h3)
        } else {
            (Vec::new(), Vec::new(), P::G1::zero())
        };
        (upper_total_evals, evals_g3_h3, proof_g3_h3)
    }

    pub fn compute_g4_h4 (
        upper_total_evals: &Vec<Vec<P::ScalarField>>,
        y_domain: &GeneralEvaluationDomain<P::ScalarField>,
        delta: &P::ScalarField,
        w: &P::ScalarField,
        u3: &P::ScalarField,
        u4: &P::ScalarField,
    ) -> Vec<UnivariatePolynomial<P::ScalarField>> { 
        let l = y_domain.size();
        let domain_8y = <GeneralEvaluationDomain<P::ScalarField> as EvaluationDomain<P::ScalarField>>::new(8 * l).unwrap();
        let polys_g4_h4 = if Net::am_master() {

            let evals = upper_total_evals.clone();
            assert_eq!(evals[0].len(), 13);
            // evaluate evaluations 
            let (evals_first, evals_second, evals_third): (Vec<P::ScalarField>, Vec<P::ScalarField>, Vec<P::ScalarField>) = par_join_3!(
                || {
                    let evals_val_pa: Vec<P::ScalarField> = evals.par_iter().map(|eval| eval[0]).collect();
                    let evals_a_pa_low: Vec<P::ScalarField> = evals.par_iter().map(|eval| eval[3]).collect();
                    let evals_a_pa_high: Vec<P::ScalarField> = evals.par_iter().map(|eval| eval[4]).collect();
                    let evals_b_pa: Vec<P::ScalarField> = evals.par_iter().map(|eval| eval[9]).collect();

                    let evals_vec = vec![evals_val_pa, evals_a_pa_low, evals_a_pa_high, evals_b_pa];
                    let polys: Vec<UnivariatePolynomial<P::ScalarField>> = evals_vec.into_par_iter().map(|evals| NoPreProver::<P>::interpolate_from_eval_domain(evals, &y_domain)).collect();

                    let evals_vec: Vec<Vec<P::ScalarField>> = polys.into_par_iter().map(|poly| poly.evaluate_over_domain(domain_8y).evals).collect();
                    assert_eq!(evals_vec[0].len(), 8 * l);
                    let evals_first: Vec<P::ScalarField> = (0..(8 * l)).into_par_iter().map(|j| {
                        evals_vec.par_iter().map(|row| row[j]).product()
                        }).collect();
                    evals_first
                }, 
                || {
                    let evals_val_pb: Vec<P::ScalarField> = evals.par_iter().map(|eval| eval[1]).collect();
                    let evals_a_pb_low: Vec<P::ScalarField> = evals.par_iter().map(|eval| eval[5]).collect();
                    let evals_a_pb_high: Vec<P::ScalarField> = evals.par_iter().map(|eval| eval[6]).collect();
                    let evals_b_pb: Vec<P::ScalarField> = evals.par_iter().map(|eval| eval[10]).collect();

                    let evals_vec = vec![evals_val_pb, evals_a_pb_low, evals_a_pb_high, evals_b_pb];
                    let polys: Vec<UnivariatePolynomial<P::ScalarField>> = evals_vec.into_par_iter().map(|evals| NoPreProver::<P>::interpolate_from_eval_domain(evals, &y_domain)).collect();

                    let evals_vec: Vec<Vec<P::ScalarField>> = polys.into_par_iter().map(|poly| poly.evaluate_over_domain(domain_8y).evals).collect();
                    assert_eq!(evals_vec[0].len(), 8 * l);
                    let evals_second: Vec<P::ScalarField> = (0..(8 * l)).into_par_iter().map(|j| {
                        evals_vec.par_iter().map(|row| row[j]).product()
                        }).collect();
                    evals_second.par_iter().map(|eval| *eval * w).collect()
                }, 
                || {
                    let evals_val_pc: Vec<P::ScalarField> = evals.par_iter().map(|eval| eval[2]).collect();
                    let evals_a_pc_low: Vec<P::ScalarField> = evals.par_iter().map(|eval| eval[7]).collect();
                    let evals_a_pc_high: Vec<P::ScalarField> = evals.par_iter().map(|eval| eval[8]).collect();
                    let evals_b_pc: Vec<P::ScalarField> = evals.par_iter().map(|eval| eval[11]).collect();

                    let evals_vec = vec![evals_val_pc, evals_a_pc_low, evals_a_pc_high, evals_b_pc];
                    let polys: Vec<UnivariatePolynomial<P::ScalarField>> = evals_vec.into_par_iter().map(|evals| NoPreProver::<P>::interpolate_from_eval_domain(evals, &y_domain)).collect();

                    let evals_vec: Vec<Vec<P::ScalarField>> = polys.into_par_iter().map(|poly| poly.evaluate_over_domain(domain_8y).evals).collect();
                    assert_eq!(evals_vec[0].len(), 8 * l);
                    let evals_third: Vec<P::ScalarField> = (0..(8 * l)).into_par_iter().map(|j| {
                        evals_vec.par_iter().map(|row| row[j]).product()
                        }).collect();
                    evals_third.par_iter().map(|eval| *eval * w.square()).collect()
                }
            );
            let evals_beta: Vec<P::ScalarField> = evals.par_iter().map(|eval| eval[12]).collect();
            let poly_beta = NoPreProver::<P>::interpolate_from_eval_domain(evals_beta, &y_domain);
            let evals_beta = poly_beta.evaluate_over_domain(domain_8y).evals;

            let evals_target = evals_first.par_iter().zip(evals_second.par_iter())
                .zip(evals_third.par_iter()).zip(evals_beta.par_iter())
                .map(|(((a, b), c), d)| (*a + *b + *c) * d * (*delta - *u3)).collect();
            let poly_target = NoPreProver::<P>::interpolate_from_eval_domain(evals_target, &domain_8y);
            let (poly_g4, mut poly_h4) = IPA::<P>::get_g_mul_u_and_h(&poly_target, &u4, &y_domain);
            let mut coeffs_h4 = take(&mut poly_h4.coeffs);
            if coeffs_h4.len() <= 3 * l {
                coeffs_h4.resize(3 * l + 1, P::ScalarField::zero());
                println!("Pad degree {} h4", poly_h4.degree())
            }
            assert!(coeffs_h4.len() < 4 * l);
            let (poly_h4_one, poly_h4_two, poly_h4_three, poly_h4_four): 
                (UnivariatePolynomial<P::ScalarField>, UnivariatePolynomial<P::ScalarField>, 
                UnivariatePolynomial<P::ScalarField>, UnivariatePolynomial<P::ScalarField>) = par_join_4!(
                || {
                    let coeffs_h4_one = coeffs_h4[0..l].to_vec();
                    UnivariatePolynomial::from_coefficients_vec(coeffs_h4_one)
                }, 
                || {
                    let coeffs_h4_two = coeffs_h4[l..(2 * l)].to_vec();
                    UnivariatePolynomial::from_coefficients_vec(coeffs_h4_two)
                }, 
                || {
                    let coeffs_h4_three = coeffs_h4[(2 * l) ..(3 * l)].to_vec();
                    UnivariatePolynomial::from_coefficients_vec(coeffs_h4_three)
                } ,
                || {
                    let coeffs_h4_four = coeffs_h4[(3 * l) ..].to_vec();
                    UnivariatePolynomial::from_coefficients_vec(coeffs_h4_four)
                }
            );
            vec![poly_g4, poly_h4_one, poly_h4_two, poly_h4_three, poly_h4_four]
        } else {
            Vec::new()
        };

        polys_g4_h4
    }

    pub fn commit_g4_h4 (
        y_srs: &Vec<P::G1Affine>,
        y_domain: &GeneralEvaluationDomain<P::ScalarField>,
        polys_g4_h4: &Vec<UnivariatePolynomial<P::ScalarField>>,
    ) -> Vec<P::G1> {
        if Net::am_master() {
            let eval_vec = polys_g4_h4.par_iter().map(|poly| poly.evaluate_over_domain_by_ref(*y_domain).evals).collect();
            BatchKZG::<P>::commit_lagrange(&y_srs, &eval_vec).unwrap()
        } else {
            Vec::new()
        }
    }

    pub fn compute_and_commit_q2 (
        sub_prover_id: usize,
        x_srs: &[P::G1Affine],
        polys_f2: &Vec<UnivariatePolynomial<P::ScalarField>>,
        x_domain: &GeneralEvaluationDomain<P::ScalarField>,
        n_polys: &NPolys<P>,
        upper_a_t_polys: &DeAandTPolys<P>,
        upper_b_t_polys: &DeBandTPolys<P>,
        v: &P::ScalarField,
        gamma: &P::ScalarField, 
        beta: &P::ScalarField,
    ) -> (UnivariatePolynomial<P::ScalarField>, P::G1) {
        // to obtain total evals on x_domain

        let domain_2x = <GeneralEvaluationDomain<P::ScalarField> as EvaluationDomain<P::ScalarField>>::new(2 * x_domain.size()).unwrap();
        let factors: Vec<P::ScalarField> = generate_powers(v, 9);

        // can first do n minus then n_ffts
        let ((evals_common, evals_t_row_low, evals_t_row_high, evals_t_col), evals_f2, n_evals) = par_join_3!(
            || par_join_4!(
                || {
                    let poly_common = &UnivariatePolynomial::from_coefficients_vec(vec![*gamma]) + &(&UnivariatePolynomial::from_coefficients_vec(vec![P::ScalarField::zero(), P::ScalarField::one()]) * *beta);
                    poly_common.evaluate_over_domain(domain_2x).evals
                }, 
                || upper_a_t_polys.t_row_low.evaluate_over_domain_by_ref(domain_2x).evals, 
                || upper_a_t_polys.t_row_high.evaluate_over_domain_by_ref(domain_2x).evals, 
                || upper_b_t_polys.t_col.evaluate_over_domain_by_ref(domain_2x).evals
            ),
            || {
                let mut combined_poly_1 = vec![P::ScalarField::zero(); polys_f2[0].coeffs.len()];
                let mut combined_poly_2 = vec![P::ScalarField::zero(); polys_f2[1].coeffs.len()];
                let mut combined_poly_3 = vec![P::ScalarField::zero(); polys_f2[6].coeffs.len()];
                par_join_3!(
                    || {
                        (&polys_f2[0].coeffs, &polys_f2[2].coeffs, &polys_f2[4].coeffs)
                            .into_par_iter()
                            .map(|(f0, f2, f4)| {
                                *f0 + *f2 * factors[2] + *f4 * factors[4]
                            })
                            .collect_into_vec(&mut combined_poly_1);
                    },
                    || {
                        (&polys_f2[1].coeffs, &polys_f2[3].coeffs, &polys_f2[5].coeffs)
                            .into_par_iter()
                            .map(|(f1, f3, f5)| {
                                *f1 * factors[1] + *f3 * factors[3] + *f5 * factors[5]
                            })
                            .collect_into_vec(&mut combined_poly_2);
                    },
                    || {
                        (&polys_f2[6].coeffs, &polys_f2[7].coeffs, &polys_f2[8].coeffs)
                            .into_par_iter()
                            .map(|(f6, f7, f8)| {
                                *f6 * factors[6] + *f7 * factors[7] + *f8 * factors[8]
                            })
                            .collect_into_vec(&mut combined_poly_3);
                        }
                );
                let combined_poly_1 = UnivariatePolynomial::from_coefficients_vec(combined_poly_1);
                let combined_poly_2 = UnivariatePolynomial::from_coefficients_vec(combined_poly_2);
                let combined_poly_3 = UnivariatePolynomial::from_coefficients_vec(combined_poly_3);

                let polys_f2 = [&combined_poly_1, &combined_poly_2, &combined_poly_3];
                let evals_f2 = polys_f2.par_iter().map(|poly| poly.evaluate_over_domain_by_ref(domain_2x).evals)
                    .collect::<Vec<_>>();
                evals_f2
            },
            || {                
                let n_polys = vec![&n_polys.row_pa_low, &n_polys.row_pa_high, &n_polys.row_pb_low, &n_polys.row_pb_high,
                    &n_polys.row_pc_low, &n_polys.row_pc_high, &n_polys.col_pa, &n_polys.col_pb, &n_polys.col_pc];
                let combined_n_poly: UnivariatePolynomial<P::ScalarField> = linear_combination_poly_by_ref::<P>(&n_polys, &v);
                let n_evals: Vec<P::ScalarField> = combined_n_poly.evaluate_over_domain_by_ref(domain_2x).evals;
                n_evals
            });
        
        let factor = -(P::ScalarField::one() + P::ScalarField::one()).inverse().unwrap();

        let evals_left = (&evals_f2[0], &evals_f2[1], &evals_f2[2], &evals_common, &evals_t_row_low, &evals_t_row_high, &evals_t_col, &n_evals)
            .into_par_iter()
            .chunks(2)
            .map(|chunk| {
                let (f0, f1, f2, common, t_low, t_high, t_col, n) = chunk[1];
                (*f0 * (*common + t_low) + *f1 * (*common + t_high) + *f2 * (*common + t_col) - n) * factor
            })
            .collect::<Vec<_>>();

        let mut poly_q2 = interpolate_from_eval_domain::<P>(evals_left, &x_domain);
        let mut elem = domain_2x.group_gen_inv();
        poly_q2.coeffs.iter_mut()
            .skip(1)
            .for_each(|coeff| {
                *coeff *= elem;
                elem *= domain_2x.group_gen_inv();
            });

        // generate com_q2 distributedly
        let size = x_srs.len() / Net::n_parties();
        let start = sub_prover_id * size;
        let end = start + size;
        let sub_coeff_q2 = slice_inbounds(&poly_q2.coeffs, start, end);
        let sub_powers = &x_srs[start..end];
        let sub_com_q2: P::G1Affine = P::G1MSM::msm_unchecked_par_auto(sub_powers, &sub_coeff_q2).into();
        let sub_coms_q2 = Net::send_to_master(&sub_com_q2);
        let com_q2 = if Net::am_master() {
            let sub_coms_q2 = sub_coms_q2.unwrap();
            sub_coms_q2.par_iter().sum()
        } else {
            P::G1::zero()
        };
        (poly_q2, com_q2)
    }

    pub fn open_t_f2_q2_n (
        sub_prover_id: usize,
        x_srs: &[P::G1Affine],
        upper_a_t_polys: &DeAandTPolys<P>,
        upper_b_t_polys: &DeBandTPolys<P>,
        polys_f2: &Vec<UnivariatePolynomial<P::ScalarField>>,
        poly_q2: &UnivariatePolynomial<P::ScalarField>,
        n_polys: &NPolys<P>,
        x_domain: &GeneralEvaluationDomain<P::ScalarField>,
        delta: &P::ScalarField,
        // gamma is usually used for batch open
        gamma: &P::ScalarField,
        transcript: &mut Transcript,
    ) -> (Vec<Vec<P::ScalarField>>, (P::G1, P::G1)) {

        let w = x_domain.group_gen();
        let t_points = vec![P::ScalarField::one(), *delta, w * delta];
        let f2_points = vec![P::ScalarField::zero(), *delta];
        let n_points = vec![*delta];
        let q_points = vec![*delta];

        let polys = vec![&upper_a_t_polys.t_row_low, &upper_a_t_polys.t_row_high, &upper_b_t_polys.t_col, 
            &polys_f2[0], &polys_f2[1], &polys_f2[2],
            &polys_f2[3], &polys_f2[4], &polys_f2[5],
            &polys_f2[6], &polys_f2[7], &polys_f2[8],
            &poly_q2,
            &n_polys.row_pa_low, &n_polys.row_pa_high, &n_polys.row_pb_low,
            &n_polys.row_pb_high,& n_polys.row_pc_low, &n_polys.row_pc_high, 
            &n_polys.col_pa, &n_polys.col_pb, &n_polys.col_pc];
        let points = vec![&t_points, &t_points, &t_points,
            &f2_points, &f2_points, &f2_points,
            &f2_points, &f2_points, &f2_points,
            &f2_points, &f2_points, &f2_points,
            &q_points, 
            &n_points, &n_points, &n_points, &n_points, 
            &n_points, &n_points, &n_points, &n_points, &n_points];

        // maunnly invoke batch KZG for efficiency
        let point_vec = vec![P::ScalarField::one(), *delta, w * delta, P::ScalarField::zero()];
        let numerator_polynomial = generator_numerator_polynomial_no_repeat::<P>(&point_vec);
        let challenge_vector = generate_powers(gamma, polys.len());

        let evals: Vec<Vec<P::ScalarField>> = polys.par_iter().zip(points.par_iter()).map(|(poly, x_points)|{
            x_points.par_iter().map(|point| poly.evaluate(&point)).collect()
        }).collect();

        // compute numerator_polynomial non-repeatedly
        let numerator_poly1 = generator_numerator_polynomial_no_repeat::<P>(&t_points);
        let numerator_poly2 = generator_numerator_polynomial_no_repeat::<P>(&f2_points);
        let numerator_poly3 = generator_numerator_polynomial_no_repeat::<P>(&n_points);
        let numerator_polys = vec![&numerator_poly1, &numerator_poly1, &numerator_poly1,
            &numerator_poly2, &numerator_poly2, &numerator_poly2,
            &numerator_poly2, &numerator_poly2, &numerator_poly2,
            &numerator_poly2, &numerator_poly2, &numerator_poly2,
            &numerator_poly3, 
            &numerator_poly3, &numerator_poly3, &numerator_poly3,
            &numerator_poly3, &numerator_poly3, &numerator_poly3,
            &numerator_poly3, &numerator_poly3, &numerator_poly3];
        let numerator_polys = numerator_polys.par_iter().zip(challenge_vector.par_iter()).map(|(poly, factor)| {
            let mut poly = (**poly).clone();
            poly.coeffs.iter_mut().for_each(|x| *x /= *factor);
            poly
        }).collect::<Vec<_>>();

        let polys_r: Vec<UnivariatePolynomial<P::ScalarField>> = points.par_iter().
            zip(evals.par_iter()).
            map(|(row_points, row_evals)| 
                interpolate_on_trivial_domain::<P>(row_points, &row_evals)
            ).collect();

        let poly_h= polys.par_iter().
            zip(polys_r.par_iter()).
            zip(numerator_polys.par_iter()).
            map(|((poly, poly_r), numerator_poly)|  {
                if numerator_poly == &numerator_poly2 {
                    let mut result = *poly - poly_r;
                    divide_by_x_minus_k(&mut result, delta);
                    result.coeffs.remove(0);
                    result
                } else if numerator_poly == &numerator_poly3 {
                    let mut result = *poly - poly_r;
                    divide_by_x_minus_k(&mut result, delta);
                    result
                } else {
                    &(*poly - poly_r) / &numerator_poly
                }
            }
            )
            .reduce_with(|acc, poly| acc + poly)
            .unwrap_or_else(UnivariatePolynomial::zero);

        // generate com_h distributedly
        let size = x_srs.len() / Net::n_parties();
        let start = sub_prover_id * size;
        let end = start + size;
        let sub_coeff_h = slice_inbounds(&poly_h.coeffs, start, end);
        let sub_powers = &x_srs[start..end];
        let sub_com_h: P::G1Affine = P::G1MSM::msm_unchecked_par_auto(sub_powers, &sub_coeff_h).into();
        let sub_coms_h = Net::send_to_master(&sub_com_h);
        let com_h = if Net::am_master() {
            let sub_coms_h = sub_coms_h.unwrap();
            sub_coms_h.par_iter().sum()
        } else {
            P::G1::zero()
        };

        // generate challenge z
        let z = if Net::am_master() {
            <Transcript as ProofTranscript<P>>::append_point(transcript, b"random_evaluate_point_z", &com_h);
            let z = <Transcript as ProofTranscript<P>>::challenge_scalar(transcript, b"random_evaluate_point_z");
            Net::recv_from_master(Some(vec![z; Net::n_parties()]));
            z
        } else {
            Net::recv_from_master(None)
        };

        let num_eval_1 = numerator_poly1.evaluate(&z);
        let num_eval_2 = numerator_poly2.evaluate(&z);
        let num_eval_3 = numerator_poly3.evaluate(&z);
        let num_evals = vec![&num_eval_1, &num_eval_1, &num_eval_1,
            &num_eval_2, &num_eval_2, &num_eval_2, 
            &num_eval_2, &num_eval_2, &num_eval_2, 
            &num_eval_2, &num_eval_2, &num_eval_2,
            &num_eval_3,
            &num_eval_3, &num_eval_3, &num_eval_3,
            &num_eval_3, &num_eval_3, &num_eval_3,
            &num_eval_3, &num_eval_3, &num_eval_3];
        let num_eval = numerator_polynomial.evaluate(&z);

        // generate polynomial fz
        let target_poly = polys.par_iter().
            zip(polys_r.par_iter()).
            zip(num_evals.par_iter()).
            zip(challenge_vector.par_iter()).
            map(|(((poly, poly_r), eval), factor)| 
            &(*poly + &UnivariatePolynomial::from_coefficients_vec(vec![-poly_r.evaluate(&z)])) * (*factor / *eval)
            )
            .reduce_with(|acc, poly| acc + poly)
            .unwrap_or_else(UnivariatePolynomial::zero);
        let mut poly_l = &(&target_poly - &poly_h) * num_eval;
        divide_by_x_minus_k(&mut poly_l, &z);

        // try to generate com_h and com_l distributedly
        let sub_coeff_l = slice_inbounds(&poly_l.coeffs, start, end);
        let sub_com_l: P::G1Affine = P::G1MSM::msm_unchecked_par_auto(sub_powers, &sub_coeff_l).into();
        let sub_coms_l = Net::send_to_master(&sub_com_l);
        let com_l = if Net::am_master() {
            let sub_coms_l = sub_coms_l.unwrap();
            sub_coms_l.par_iter().sum()
        } else {
            P::G1::zero()
        };

        (evals, (com_h, com_l))
    }

    pub fn open_val_upper_lower_a_b_f1 (
        sub_m_powers: &Vec<P::G1Affine>,
        m_y_srs: &Vec<P::G1Affine>,
        val_polys: &DeValPolys<P>,
        upper_a_t_polys: &DeAandTPolys<P>,
        upper_b_t_polys: &DeBandTPolys<P>,
        lower_a_b_polys: &DeLowerAandBPolys<P>,
        val_upper_l_evals: &Vec<P::ScalarField>,
        lower_evals: &Vec<P::ScalarField>,
        sub_polys_f1: &Vec<UnivariatePolynomial<P::ScalarField>>,
        y_domain: &GeneralEvaluationDomain<P::ScalarField>,
        delta: &P::ScalarField,
        zeta: &P::ScalarField,
        gamma: &P::ScalarField,
    ) -> (UnivariatePolynomial<P::ScalarField>, Vec<P::ScalarField>, (P::G1, P::G1)) {
        let precombined_f1 = linear_combination_poly_by_ref::<P>(&sub_polys_f1.iter().collect(), gamma);

        // val, row, col, lower_pa, lower_b, f1
        let sub_polys = vec![
            &val_polys.val_pa, &val_polys.val_pb, &val_polys.val_pc,
            &upper_a_t_polys.a_pa_low, &upper_a_t_polys.a_pa_high, 
            &upper_a_t_polys.a_pb_low, &upper_a_t_polys.a_pb_high, 
            &upper_a_t_polys.a_pc_low, &upper_a_t_polys.a_pc_high,
            &upper_b_t_polys.b_pa, &upper_b_t_polys.b_pb, &upper_b_t_polys.b_pc,
            &lower_a_b_polys.la_pa_low, &lower_a_b_polys.la_pa_high, 
            &lower_a_b_polys.la_pb_low, &lower_a_b_polys.la_pb_high, 
            &lower_a_b_polys.la_pc_low, &lower_a_b_polys.la_pc_high, 
            &lower_a_b_polys.lb_pa, &lower_a_b_polys.lb_pb, &lower_a_b_polys.lb_pc, 
            &precombined_f1,
        ];
        // let evals_slice: Vec<P::ScalarField> = val_upper_l_evals[..9].to_vec();
        let mut evals_slice: Vec<P::ScalarField> = val_upper_l_evals.clone();
        evals_slice.pop();
        evals_slice.extend(lower_evals);

        let evals_f: Vec<P::ScalarField> = sub_polys_f1.par_iter().map(|poly| poly.evaluate(delta)).collect();
        evals_slice.extend(evals_f);

        let proof = BivBatchKZG::<P>::de_open_lagrange_with_eval(&sub_m_powers, &m_y_srs, &sub_polys, &evals_slice, &(*delta, *zeta), &y_domain, gamma);
        if Net::am_master() {
            let (evals, proof) = proof.unwrap();
            (precombined_f1, evals, proof)
        } else {
            (precombined_f1, Vec::new(), (P::G1::zero(), P::G1::zero()))
        }
    }

    // include compute and send sub-evaluations
    // open at zero, zero
    pub fn open_f1 (
        sub_m_powers: &Vec<P::G1Affine>,
        m_y_srs: &Vec<P::G1Affine>,
        sub_polys_f1: &Vec<UnivariatePolynomial<P::ScalarField>>,
        precombined_f1: &UnivariatePolynomial<P::ScalarField>,
        y_domain: &GeneralEvaluationDomain<P::ScalarField>,
        gamma: &P::ScalarField,
    ) -> (Vec<P::ScalarField>, (P::G1, P::G1)) {
        let evals_slice = sub_polys_f1.par_iter().map(|poly| poly.coeffs[0]).collect();

        let proof = BivBatchKZG::<P>::de_open_lagrange_with_eval(&sub_m_powers, &m_y_srs, &[precombined_f1], &evals_slice, &(P::ScalarField::zero(), P::ScalarField::zero()), &y_domain, gamma);
        if Net::am_master() {
            proof.unwrap()
        } else {
            (Vec::new(), (P::G1::zero(), P::G1::zero()))
        }
    }

    pub fn open_g3_h3 (
        g3_h3_evals: &Vec<Vec<P::ScalarField>>,
        proofs_g3_h3: &Vec<P::G1>,
    ) -> (Vec<P::ScalarField>, P::G1) {
        let (eval_g3, eval_h3_low, eval_h3_mid, eval_h3_high): (P::ScalarField, P::ScalarField, P::ScalarField, P::ScalarField) = if Net::am_master() {
            (
                g3_h3_evals.par_iter().map(|evals| evals[0]).sum(),
                g3_h3_evals.par_iter().map(|evals| evals[1]).sum(),
                g3_h3_evals.par_iter().map(|evals| evals[2]).sum(),
                g3_h3_evals.par_iter().map(|evals| evals[3]).sum()
            )
        } else {(P::ScalarField::zero(), P::ScalarField::zero(), P::ScalarField::zero(), P::ScalarField::zero())};

        let evals_g3_h3 = vec![eval_g3, eval_h3_low, eval_h3_mid, eval_h3_high];
        let proof_g3_h3 = proofs_g3_h3.par_iter().map(|proof| proof).sum();

        (evals_g3_h3, proof_g3_h3)
    }

    // the polynomial L(beta, Y) has degree (l, l), but we only have (m, l) srs
    // so here use unchecked msm
    pub fn open_l_beta_zeta (
        sub_powers: &Vec<P::G1Affine>,
        y_srs: &Vec<P::G1Affine>,
        de_poly_l: &UnivariatePolynomial<P::ScalarField>,
        eval_beta: &P::ScalarField,
        y_domain: &GeneralEvaluationDomain<P::ScalarField>,
        beta: &P::ScalarField,
        zeta: &P::ScalarField,
        gamma: &P::ScalarField,
    ) -> (Vec<P::ScalarField>, (P::G1, P::G1)) {

        // invoke the de-open
        let proof = BivBatchKZG::<P>::de_open_lagrange_with_eval(&sub_powers, &y_srs, &vec![de_poly_l], &vec![*eval_beta], &(*beta, *zeta), &y_domain, &gamma);
        if Net::am_master() {
            proof.unwrap()
        } else {
            (Vec::new(), (P::G1::zero(), P::G1::zero()))
        }
    }

    // Only P0 works to open g4_h4
    pub fn open_g4_h4_g5_h5 (
        y_srs: &Vec<P::G1Affine>,
        y_domain: &GeneralEvaluationDomain<P::ScalarField>,
        polys_g4_h4: &Vec<UnivariatePolynomial<P::ScalarField>>,
        polys_g5_h5: &Vec<UnivariatePolynomial<P::ScalarField>>,
        zeta: &P::ScalarField,
        gamma: &P::ScalarField,
    ) -> (Vec<P::ScalarField>, P::G1) {
        if Net::am_master(){
            let polys = polys_g4_h4.iter()
                .chain(polys_g5_h5.iter())
                .collect::<Vec<_>>();
            let evals: Vec<P::ScalarField> = polys.par_iter().map(|poly| poly.evaluate(&zeta)).collect();

            let evals_on_domain: Vec<Vec<P::ScalarField>> = polys.par_iter().map(|poly| poly.evaluate_over_domain_by_ref(*y_domain).evals).collect();
            let proof = BatchKZG::<P>::open_lagrange(&y_srs, &evals_on_domain, &zeta, &y_domain, &gamma).unwrap();

            assert_eq!(evals.len(), 7);
            (evals, proof)
        } else {
            (Vec::new(), P::G1::zero())
        }
    }

}
use ark_poly::{univariate::DensePolynomial as UnivariatePolynomial, DenseUVPolynomial, EvaluationDomain, GeneralEvaluationDomain, Polynomial};
use std::marker::PhantomData;
use ark_ec::pairing::Pairing;
use my_kzg::{biv_batch_kzg::BivBatchKZG, biv_trivial_kzg::VerifierSRS, helper::{evaluate_one_lagrange, linear_combination_field}, transcript::ProofTranscript, uni_batch_kzg::BatchKZG, uni_trivial_kzg::{KZG, UniVerifierSRS}};
use merlin::Transcript;
use my_ipa::ipa::IPA;
use my_ipa::helper::{R1CSPublicPolys, R1CSWitnessPolys};
use ark_ff::{Zero, One, Field};
use de_network::{DeMultiNet as Net, DeNet, DeSerNet};
use rayon::prelude::*;
use crate::{indexer::{PreMesProver, PreMesVerifier}, prover_nopre::NoPreProver};
use my_kzg::par_join_3;
use crate::prover_pre::PreProver;
use crate::par_join_4;
use std::mem::take;
use ark_std::{start_timer, end_timer};
use my_kzg::helper::generate_powers;
use ark_serialize::{CanonicalSerialize, CanonicalDeserialize};

pub struct DeSNARKLog<P: Pairing> {
    _pairing: PhantomData<P>,
}

// coms_lower, coms_val, com_R, com_L are generated by the indexer
pub struct SNARKProofLog<P: Pairing> {
    coms_wit_polys: Vec<P::G1>,
    coms_upper_a: Vec<P::G1>,
    coms_g1_h1: Vec<P::G1>,
    coms_upper_b: Vec<P::G1>,
    coms_g2_h2: Vec<P::G1>,
    coms_f1: Vec<P::G1>,
    coms_g3_h3: Vec<P::G1>,
    coms_g4_h4_g5_h5: Vec<P::G1>,
    com_q1: P::G1,
    coms_t_f2_q2: Vec<P::G1>,
    evals_wit_upper_r_polys: Vec<P::ScalarField>,
    evals_p_alpha_beta: Vec<P::ScalarField>,
    evals_g1_h1: Vec<P::ScalarField>,
    evals_g2_h2: Vec<P::ScalarField>,
    evals_g3_h3: Vec<P::ScalarField>,
    evals_g4_h4_g5_h5: Vec<P::ScalarField>,
    eval_q1: P::ScalarField,
    evals_t_f2_q2_n: Vec<Vec<P::ScalarField>>,
    evals_val_upper_lower_a_b_f1: Vec<P::ScalarField>,
    evals_f1: Vec<P::ScalarField>,
    eval_l: Vec<P::ScalarField>,
    proofs_wit_upper_r_polys: (P::G1, Vec<P::ScalarField>, P::ScalarField, (P::G1, P::G1), P::G1),
    proof_g1_h1: P::G1,
    proof_g2_h2: P::G1,
    proof_g3_h3: P::G1,
    proof_g4_h4_g5_h5: P::G1,
    proof_q1: P::G1,
    proof_t_f2_q2_n: (P::G1, P::G1),
    proof_val_upper_lower_a_b_f1: (P::G1, P::G1),
    proof_f1: (P::G1, P::G1),
    proof_l: (P::G1, P::G1),
}

impl<P: Pairing> DeSNARKLog<P> {
    pub fn de_r1cs_prove (
        sub_prover_id: usize,
        sub_powers: &Vec<P::G1Affine>,
        sub_m_powers: &Vec<P::G1Affine>,
        x_srs: &Vec<P::G1Affine>,
        y_srs: &Vec<P::G1Affine>,
        m_srs: &Vec<P::G1Affine>,
        m_y_srs: &Vec<P::G1Affine>,
        wit_polys: &R1CSWitnessPolys<P>,
        pub_polys: &R1CSPublicPolys<P>,
        pre_mes_prover: &PreMesProver<P>,
        r: &P::ScalarField,
        x_domain: &GeneralEvaluationDomain<P::ScalarField>,
        y_domain: &GeneralEvaluationDomain<P::ScalarField>,
        m_domain: &GeneralEvaluationDomain<P::ScalarField>,
        transcript: &mut Transcript,
    ) -> Option<SNARKProofLog<P>> {

        let m = x_srs.len();
        let l = Net::n_parties();

        // Derive the message
        let PreMesProver { upper_r_poly, de_row_index_vec, de_col_index_vec, val_evals, val_polys, lower_a_b_evals, lower_a_b_polys, n_evals, n_polys, de_poly_l } = pre_mes_prover;
        let row_index_vec = de_row_index_vec;
        let col_index_vec = de_col_index_vec;

        // commit secret polynomials
        let step = start_timer!(|| "commit witnesses");
        let coms_wit_polys = NoPreProver::<P>::commit_wit_polys( &sub_powers, &wit_polys);
        end_timer!(step);

        // generate challenges v and u1
        let (v, u1) = if Net::am_master() {
            let slice: &[P::G1] = &coms_wit_polys;
            <Transcript as ProofTranscript<P>>::append_points(transcript, b"v_and_u1", slice);
            let v = <Transcript as ProofTranscript<P>>::challenge_scalar(transcript, b"rlc");
            let u1 = <Transcript as ProofTranscript<P>>::challenge_scalar(transcript, b"random_ldt_padding");
            Net::recv_from_master(Some(vec![(v, u1); Net::n_parties()]));
            (v, u1)
        } else {
            Net::recv_from_master(None)
        };

        // compute polynomials evaluated at r: evals_r and the first-round target polynomial: polynomial_target
        let step = start_timer!(|| "compute evals r and target");
        // compute several auxiliary polys and evals about r 
        // R_i(X) = X^{i-1} and evals R_i(r^{m})
        let eval_r  = r.pow([(m * sub_prover_id) as u64]);
        let r_pow_m = r.pow([m as u64]);
        let (evals_r, polynomial_target) = NoPreProver::<P>::compute_evals_r_and_1st_target_poly(m, &wit_polys, &pub_polys, &r, &eval_r, &r_pow_m, &v);
        end_timer!(step);

        // compute A, T, g1, h1 polys and commit them
        // After receiving r, compute A_high, A_low, T_high, T_low from rows
        let step = start_timer!(|| "compute upper a t polys from rows");
        let (upper_a_t_polys, upper_a_t_evals) = PreProver::<P>::compute_upper_a_t_polys_from_rows(m, l, &x_domain, &m_domain, &row_index_vec, &r);
        end_timer!(step);
        // get g1 and h1
        let step = start_timer!(|| "get g1, h1");
        let (poly_g1, poly_h1) = IPA::<P>::get_g_mul_u_and_h(&polynomial_target, &u1, &x_domain);
        end_timer!(step);
        // Note:: here coms_upper_a are de_commitments
        let step = start_timer!(|| "commit g1 h1 upper a t");
        let (coms_upper_a, de_coms_g1_h1_t) = PreProver::commit_g1_h1_upper_a_t_polys(sub_prover_id, &sub_m_powers, &x_srs, &poly_g1, &poly_h1, &upper_a_t_polys);
        end_timer!(step);

        // send com of A_low, A_high, g1, h1 to P0
        let mut com_g1_h1_slice = vec![de_coms_g1_h1_t[0]];
        com_g1_h1_slice.push(de_coms_g1_h1_t[1]);
        let com_g1_h1_slices = Net::send_to_master(&com_g1_h1_slice);

        // generate the final commitments of A_low, A_high, g1, h1, t_low, t_high, total 10 coms, and t_low, t_high only held by P_0
        let coms_g1_h1_t = if Net::am_master() {
            let com_g1_h1_slices = com_g1_h1_slices.unwrap();
            let coms_g1_h1: Vec<P::G1> = (0..com_g1_h1_slices[0].len()).map(|i| {
                com_g1_h1_slices.par_iter().map(|coms| coms[i]).sum()
            }).collect();
            let mut coms_g1_h1_t = coms_g1_h1;
            coms_g1_h1_t.push(de_coms_g1_h1_t[2]);
            coms_g1_h1_t.push(de_coms_g1_h1_t[3]);
            coms_g1_h1_t
        } else {
            Vec::new()
        };
        let coms_g1_h1 = if Net::am_master() {
            vec![coms_g1_h1_t[0].clone(), coms_g1_h1_t[1].clone()]
        } else {
            Vec::new()
        };
        let coms_a_t = if Net::am_master() {
            vec![coms_g1_h1_t[2].clone(), coms_g1_h1_t[3].clone()]
        } else {
            Vec::new()
        };

        // generate new challenges alpha and u2
        let (alpha, u2, gamma) = if Net::am_master() {
            let mut coms = coms_upper_a.clone();
            coms.extend(&coms_g1_h1.clone());
            coms.extend(&coms_a_t.clone());
            let slice: &[P::G1] = &coms;
            <Transcript as ProofTranscript<P>>::append_points(transcript, b"alpha_and_u2", slice);
            let alpha = <Transcript as ProofTranscript<P>>::challenge_scalar(transcript, b"random_evaluation_for_x");
            let u2 = <Transcript as ProofTranscript<P>>::challenge_scalar(transcript, b"random_ldt_padding");
            let gamma = <Transcript as ProofTranscript<P>>::challenge_scalar(transcript, b"batch_kzg");
            Net::recv_from_master(Some(vec![(alpha, u2, gamma); Net::n_parties()]));
            (alpha, u2, gamma)
        } else {
            Net::recv_from_master(None)
        };

        // compute upper B polys and t
        let step = start_timer!(|| "compute upper b t polys");
        let (upper_b_t_polys, upper_b_t_evals) = PreProver::<P>::compute_upper_b_t_polys_from_cols(m, &x_domain, &m_domain, &col_index_vec, &alpha);
        end_timer!(step);

        let step = start_timer!(|| "commit upper b polys");
        let coms_upper_b = PreProver::<P>::commit_upper_b_polys(&sub_m_powers, &upper_b_t_polys);
        end_timer!(step);

        // evaluate and send polynomial evaluations on alpha
        // also send g1(alpha) and h1(alpha)
        let step = start_timer!(|| "evals alpha, g1, h1");
        let eval_r = eval_r;
        // pa, pb, pc, w, ar, b
        let evals_alpha = NoPreProver::<P>::compute_evals_alpha(&wit_polys, &pub_polys, &r, &alpha);
        // slices of g1(alpha) and h1(alpha)
        let eval_g1 = poly_g1.evaluate(&alpha);
        let eval_h1 = poly_h1.evaluate(&alpha);
        end_timer!(step);

        let proof_g1_h1 = BatchKZG::<P>::open(&x_srs, &vec![&poly_g1, &poly_h1], &alpha, &gamma).unwrap();

        // pa_alpha, pb_alpha, pc_alpha, w_alpha, a_r_alpha, a_r, b_alpha, b_r_inverse, b_0, c_r, R
        let evals = vec![evals_alpha[0], evals_alpha[1], evals_alpha[2], evals_alpha[3], evals_alpha[4], evals_r[0], 
                                                            evals_alpha[5], evals_r[2], evals_r[1], evals_r[3], eval_r,
                                                            eval_g1, eval_h1];
        let message_slice = Net::send_to_master(&(evals, proof_g1_h1));
        let message = if Net::am_master() {
            message_slice.unwrap()
        } else {
            Vec::new()
        };

        let step = start_timer!(|| "g1 h1, g2 h2, t_col");
        let (evals_g1_h1, proof_g1_h1, coms_g2_h2, evals_domain_g2_h2, polynomials_y, polys_g2_h2) = if Net::am_master() {
            // g1(alpha) and h1(alpha)  
            let (evals_g1_h1, proof_g1_h1) = NoPreProver::<P>::open_g1_h1(&message);
            // compute univariate polynomials evaluations at alpha and the target poly over Y for univariate sum-check
            let (polynomials_y, polynomial_target_y) = NoPreProver::<P>::compute_y_polys_and_2nd_target_poly(l, &message, &y_domain, &r_pow_m, &alpha, &u1, &v);

            // get g2, h2low, h2high
            let (poly_g2, mut poly_h2) = IPA::<P>::get_g_mul_u_and_h(&polynomial_target_y, &u2, &y_domain);
            let mut coeffs_h2 = take(&mut poly_h2.coeffs);
            if coeffs_h2.len() <= l {
                coeffs_h2.resize(l + 1, P::ScalarField::zero());
                println!("Pad degree {} h2", poly_h2.degree())
            }
            assert!(coeffs_h2.len() > l);
            let coeffs_h2_high = coeffs_h2.split_off(l);
            let poly_h2_low = UnivariatePolynomial::from_coefficients_vec(coeffs_h2);
            let poly_h2_high = UnivariatePolynomial::from_coefficients_vec(coeffs_h2_high);

            // get lagrange evaluations of g2, h2low, h2high to invoke the commitment generation
            let (evals_g2, evals_h2_low, evals_h2_high) = par_join_3!(
                || poly_g2.evaluate_over_domain_by_ref(*y_domain).evals,
                || poly_h2_low.evaluate_over_domain_by_ref(*y_domain).evals,
                || poly_h2_high.evaluate_over_domain_by_ref(*y_domain).evals
            );
            let polys_g2_h2 = vec![poly_g2, poly_h2_low, poly_h2_high];
            // compute commitments to g2, h2low, h2high
            let evals_domain_g2_h2 = vec![evals_g2, evals_h2_low, evals_h2_high];
            let coms_g2_h2 = BatchKZG::<P>::commit_lagrange(&y_srs, &evals_domain_g2_h2).unwrap();

            (evals_g1_h1, proof_g1_h1, coms_g2_h2, evals_domain_g2_h2, polynomials_y, polys_g2_h2)
        } else {
            (Vec::new(), P::G1::zero(), Vec::new(), Vec::new(), Vec::new(), Vec::new())
        };
        let com_b_t = PreProver::<P>::commit_t_col(sub_prover_id, &x_srs, &upper_b_t_polys);
        end_timer!(step);

        // get challenge beta from fiat shamir
        let beta = if Net::am_master() {
            let mut coms = coms_g2_h2.clone();
            coms.extend(&coms_upper_b);
            coms.push(com_b_t.clone());
            let slice: &[P::G1] = &coms;
            <Transcript as ProofTranscript<P>>::append_points(transcript, b"beta", slice);
            let beta = <Transcript as ProofTranscript<P>>::challenge_scalar(transcript, b"random_evaluation_for_y");
            Net::recv_from_master(Some(vec![beta; Net::n_parties()]));
            beta
        } else {
            Net::recv_from_master(None)
        };

        let step = start_timer!(|| "g2, h2, fa, fb, fc, fw, R evals and proofs");
        let (evals_g1_h1, proof_g1_h1, evals_wit_upper_r_polys, evals_g2_h2, proof_g2_h2) = if Net::am_master() {
            // compute proof and evaluations to g2, h2low, h2high
            let proof_g2_h2 = BatchKZG::<P>::open_lagrange(&y_srs, &evals_domain_g2_h2, &beta, &y_domain, &gamma).unwrap();
            let eval_g2 = polys_g2_h2[0].evaluate(&beta);
            let eval_h2_low = polys_g2_h2[1].evaluate(&beta);
            let eval_h2_high = polys_g2_h2[2].evaluate(&beta);
            
            // pa_alpha, pb_alpha, pc_alpha, w_alpha, a_r_alpha, a_r, b_alpha, b_r_inverse, b_0, c_r, R
            let eval_w_alpha_beta = polynomials_y[3].evaluate(&beta);
            let eval_ar_alpha_beta = polynomials_y[4].evaluate(&beta);
            let eval_a_r_beta = polynomials_y[5].evaluate(&beta);
            let eval_b_alpha_beta = polynomials_y[6].evaluate(&beta);
            let eval_b_r_inverse_beta = polynomials_y[7].evaluate(&beta);
            let eval_b_0_beta = polynomials_y[8].evaluate(&beta);
            let eval_c_r_beta = polynomials_y[9].evaluate(&beta);
            let eval_r_beta = polynomials_y[10].evaluate(&beta);

            let evals_wit_upper_r_polys = vec![
                eval_w_alpha_beta, eval_ar_alpha_beta, eval_a_r_beta, 
                eval_b_alpha_beta, eval_b_r_inverse_beta, eval_b_0_beta, eval_c_r_beta, 
                eval_r_beta];
            let evals_g2_h2 = vec![eval_g2, eval_h2_low, eval_h2_high];
            (evals_g1_h1, proof_g1_h1, evals_wit_upper_r_polys, evals_g2_h2, proof_g2_h2)
        } else {
            (Vec::new(), P::G1::zero(), Vec::new(), Vec::new(), P::G1::zero())
        };
        end_timer!(step);

        // compute public polys evaluations at (alpha, beta)
        let step = start_timer!(|| "compute pub evals at (alpha, beta)");
        let eval_beta = evaluate_one_lagrange::<P>(sub_prover_id, &y_domain, &beta);
        let evals_p_alpha_beta: Vec<<P as Pairing>::ScalarField> = PreProver::<P>::compute_pub_evals_alpha_beta(&upper_a_t_evals, &upper_b_t_evals, &val_evals, &eval_beta);
        assert_eq!(evals_p_alpha_beta.len(), 3);
        end_timer!(step);

        // compute and commit f1 and f2
        // lower_evals describes ai, bi evals such that a_low(g^i) = w^{row_low(g^i)}
        let step = start_timer!(|| "compute sub f1 f2");
        let (de_polys_f1, polys_f2) = PreProver::<P>::compute_sub_f1_and_f2(&lower_a_b_evals, &upper_a_t_evals, &upper_b_t_evals, &n_evals, &m_domain, &x_domain, &gamma, &beta);
        end_timer!(step);

        let step = start_timer!(|| "commit sub f1 f2");
        let (coms_f1, coms_f2) = PreProver::<P>::commit_f1_f2(sub_prover_id, &sub_m_powers, &x_srs, &de_polys_f1, &polys_f2);
        end_timer!(step);

        // generate challenges w, u3
        let (w, u3) = if Net::am_master() {
            let mut coms = coms_f1.clone();
            coms.extend(&coms_f2);
            let slice: &[P::G1] = &coms;
            <Transcript as ProofTranscript<P>>::append_points(transcript, b"u3", slice);
            let w = <Transcript as ProofTranscript<P>>::challenge_scalar(transcript, b"rlc");
            let u3 = <Transcript as ProofTranscript<P>>::challenge_scalar(transcript, b"random_ldt_padding");
            Net::recv_from_master(Some(vec![(w, u3); Net::n_parties()]));
            (w, u3)
        } else {
            Net::recv_from_master(None)
        };

        // compute and commit polys g3, h3low, h3mid, h3high
        let step = start_timer!(|| "compute g3 h3");
        let polys_g3_h3 = PreProver::<P>::compute_g3_h3(&val_polys, &upper_a_t_polys, &upper_b_t_polys, &m_domain, &eval_beta, &w, &u3);
        end_timer!(step);

        let step = start_timer!(|| "commit g3 h3");
        let coms_g3_h3 = PreProver::<P>::commit_g3_h3(&m_srs, &polys_g3_h3);
        end_timer!(step);

        // generate challenges delta and u4
        let (delta, u4) = if Net::am_master() {
            let slice: &[P::G1] = &coms_g3_h3;
            <Transcript as ProofTranscript<P>>::append_points(transcript, b"delta_u4", slice);
            let delta = <Transcript as ProofTranscript<P>>::challenge_scalar(transcript, b"random_evaluation_for_x");
            let u4 = <Transcript as ProofTranscript<P>>::challenge_scalar(transcript, b"random_ldt_padding");
            Net::recv_from_master(Some(vec![(delta, u4); Net::n_parties()]));
            (delta, u4)
        } else {
            Net::recv_from_master(None)
        };

        // compute evals at delta (or beta for L_i(beta)) of upper and lower polys
        let step = start_timer!(|| "compute evals at delta beta");
        let (val_upper_and_l_evals, lower_evals, evals_g3_h3, proof_g3_h3) = PreProver::<P>::compute_evals_at_delta_beta_and_g3_h3_proofs(
            &m_srs, &val_polys, &upper_a_t_polys, &upper_b_t_polys, &lower_a_b_polys, &eval_beta, &polys_g3_h3, &delta, &gamma);
        // send them to P_0, compute proofs and evals of g3, h3
        let (val_upper_and_l_total_evals, evals_g3_h3, proof_g3_h3) = PreProver::<P>::send_evals_at_delta_beta_and_g3_h3_proofs(&val_upper_and_l_evals, &evals_g3_h3, &proof_g3_h3);
        end_timer!(step);

        // compute and commit polys g4,h4
        let step = start_timer!(|| "compute g4 h4");
        let polys_g4_h4 = PreProver::<P>::compute_g4_h4(&val_upper_and_l_total_evals, &y_domain, &delta, &w, &u3, &u4);
        end_timer!(step);

        let step = start_timer!(|| "commit g4 h4");
        let coms_g4_h4 = PreProver::<P>::commit_g4_h4(&y_srs, &y_domain, &polys_g4_h4);
        end_timer!(step);

        // compute and commit q2
        let step = start_timer!(|| "compute & commit q2");
        let (poly_q2, com_q2) = PreProver::<P>::compute_and_commit_q2(sub_prover_id, &x_srs, &polys_f2, &x_domain, &n_polys, &upper_a_t_polys, &upper_b_t_polys, &v, &gamma, &beta);
        end_timer!(step);

        // compute and commit q1, compute and commit g5 h5
        let step = start_timer!(|| "compute & commit q1");
        let (sub_poly_q1, com_q1) = PreProver::<P>::compute_and_commit_q1(&m_srs, &m_domain, &de_polys_f1, &upper_a_t_polys, &upper_b_t_polys, &lower_a_b_polys, &v, &gamma, &beta);
        end_timer!(step);

        let step = start_timer!(|| "open q1");
        let (eval_q1, proof_q1) = PreProver::<P>::open_q1(&m_srs, &sub_poly_q1, &delta);
        end_timer!(step);

        let step = start_timer!(|| "compute & commit g5 h5");
        let (polys_g5_h5, coms_g5_h5) = PreProver::<P>::compute_and_commit_g5_h5(&y_srs, &de_polys_f1, &val_upper_and_l_total_evals, &lower_evals, &y_domain, &delta, &beta, &gamma, &v, &u4,
            &eval_q1, &m_domain);
        let mut coms_g4_h4_g5_h5 = coms_g4_h4.clone();
        coms_g4_h4_g5_h5.extend(&coms_g5_h5);
        end_timer!(step);

        // generate challenge zeta
        let zeta = if Net::am_master() {
            let slice: &[P::G1] = &coms_g4_h4_g5_h5;
            <Transcript as ProofTranscript<P>>::append_points(transcript, b"zeta", slice);
            let zeta = <Transcript as ProofTranscript<P>>::challenge_scalar(transcript, b"random_evaluation_for_y");
            Net::recv_from_master(Some(vec![zeta; Net::n_parties()]));
            zeta
        } else {
            Net::recv_from_master(None)
        };

        // generate proof to alpha, beta
        // also open R(r^m, beta)
        // Note:: this involves transcript, must put after the generation of the last challenge
        let step = start_timer!(|| "open bivariate polynomials");
        let x_points = vec![vec![alpha], vec![*r * alpha, *r], vec![alpha, r.inverse().unwrap(), P::ScalarField::zero()], vec![*r], vec![r_pow_m]];
        let sub_polynomials = vec![&wit_polys.poly_w, &wit_polys.poly_a, &wit_polys.poly_b, &wit_polys.poly_c, &upper_r_poly];
        let proofs_wit_upper_r_polys= BivBatchKZG::<P>::de_open_lagrange_at_same_y(sub_prover_id, &sub_powers, &x_srs, &y_srs, &sub_polynomials, &x_points, &beta, &y_domain, transcript, &gamma);
        end_timer!(step);

        // open g4 h4, only P_0 works
        let step = start_timer!(|| "open g4, h4, g5, h5");
        let (evals_g4_h4_g5_h5, proof_g4_h4_g5_h5) = PreProver::<P>::open_g4_h4_g5_h5(&y_srs, &y_domain, &polys_g4_h4, &polys_g5_h5, &zeta, &gamma);
        end_timer!(step);

        // open t and f2, only P_0 works
        // Note:: this also involves transcript
        let step = start_timer!(|| "open t, f2, q2, n");
        let coms_t_f2_q2 = if Net::am_master() {
            let mut coms_t_f2_q2 = coms_a_t;
            coms_t_f2_q2.push(com_b_t);
            coms_t_f2_q2.extend(&coms_f2);
            coms_t_f2_q2.push(com_q2);
            coms_t_f2_q2
        } else {
            Vec::new()
        };
        let (evals_t_f2_q2_n, proof_t_f2_q2_n) = PreProver::<P>::open_t_f2_q2_n(sub_prover_id, &x_srs, &upper_a_t_polys, &upper_b_t_polys, &polys_f2, &poly_q2, &n_polys, &x_domain, &delta, &gamma, transcript);
        if Net::am_master() {
            assert_eq!(evals_t_f2_q2_n.len(), 22);
            assert_eq!(evals_t_f2_q2_n[0].len(), 3);
            assert_eq!(evals_t_f2_q2_n[3].len(), 2);
        }
        end_timer!(step);

        // open val_upper_lower_a_b at (delta, zeta)
        let step = start_timer!(|| "open val, A, B, a, b at (delta, zeta)");
        let (precombined_f1, evals_val_upper_lower_a_b_f1, proof_val_upper_lower_a_b_f1) = PreProver::<P>::open_val_upper_lower_a_b_f1(
            &sub_m_powers,
            &m_y_srs,
            &val_polys, 
            &upper_a_t_polys, 
            &upper_b_t_polys, 
            &lower_a_b_polys, 
            &val_upper_and_l_evals, 
            &lower_evals, 
            &de_polys_f1, 
            &y_domain, &delta, &zeta, &gamma);
        end_timer!(step);

        // open f1 at (0, 0)
        let step = start_timer!(|| "open f1 at (0, 0)");
        let (evals_f1, proof_f1) = PreProver::<P>::open_f1(&sub_m_powers, &m_y_srs, &de_polys_f1, &precombined_f1, &y_domain, &gamma);
        end_timer!(step);

        // open L at (beta, zeta)
        // the prover doesn't need to compute com to L(X, Y) as it is generated by indexer
        let step = start_timer!(|| "open L at (beta, zeta)");
        let (eval_l, proof_l) = PreProver::<P>::open_l_beta_zeta(&sub_powers, &y_srs, &de_poly_l, &eval_beta, &y_domain, &beta, &zeta, &gamma);
        if Net::am_master() {
            assert_eq!(eval_l.len(), 1);
        }
        end_timer!(step);

        if Net::am_master() {
            Some(SNARKProofLog {
                coms_wit_polys,
                coms_upper_a,
                coms_g1_h1,
                coms_upper_b,
                coms_g2_h2,
                coms_f1,
                coms_g3_h3,
                coms_g4_h4_g5_h5,
                com_q1,
                coms_t_f2_q2,
                evals_wit_upper_r_polys,
                evals_p_alpha_beta,
                evals_g1_h1,
                evals_g2_h2,
                evals_g3_h3,
                evals_g4_h4_g5_h5,
                eval_q1,
                evals_t_f2_q2_n,
                evals_val_upper_lower_a_b_f1,
                evals_f1,
                eval_l,
                proofs_wit_upper_r_polys: proofs_wit_upper_r_polys.unwrap(),
                proof_g1_h1,
                proof_g2_h2,
                proof_g3_h3,
                proof_g4_h4_g5_h5,
                proof_q1,
                proof_t_f2_q2_n,
                proof_val_upper_lower_a_b_f1,
                proof_f1,
                proof_l, 
            })
        } else {
            None
        }
    }

    pub fn r1cs_verify_preprocess(
        v_srs: &VerifierSRS<P>,
        m_v_srs: &VerifierSRS<P>,
        pre_mes_verifier: &PreMesVerifier<P>,
        proof: &SNARKProofLog<P>,
        x_domain: &GeneralEvaluationDomain<P::ScalarField>,
        y_domain: &GeneralEvaluationDomain<P::ScalarField>,
        m_domain: &GeneralEvaluationDomain<P::ScalarField>,
        r: &P::ScalarField,
        transcript: &mut Transcript,
    ) -> bool {
        // Derive the verifier messages
        let PreMesVerifier { com_upper_r, coms_val, coms_lower_a_b, com_l, coms_n } = pre_mes_verifier;

        let m = x_domain.size();
        let l = y_domain.size();
        let m_prime = m_domain.size();
        let r_pow_m = r.pow([m as u64]);
        let uni_v_srs_for_x = UniVerifierSRS {
            g: v_srs.g.clone(),
            h: v_srs.h.clone(),
            h_alpha: v_srs.h_alpha.clone()
        };
        let uni_v_srs_for_y = UniVerifierSRS {
            g: v_srs.g.clone(),
            h: v_srs.h.clone(),
            h_alpha: v_srs.h_beta.clone()
        };

        let uni_m_v_srs_for_x = UniVerifierSRS {
            g: m_v_srs.g.clone(),
            h: m_v_srs.h.clone(),
            h_alpha: m_v_srs.h_alpha.clone()
        };

        let SNARKProofLog {
            coms_wit_polys,
            coms_upper_a,
            coms_g1_h1,
            coms_upper_b,
            coms_g2_h2,
            coms_f1,
            coms_g3_h3,
            coms_g4_h4_g5_h5,
            com_q1,
            coms_t_f2_q2,
            evals_wit_upper_r_polys,
            evals_p_alpha_beta,
            evals_g1_h1,
            evals_g2_h2,
            evals_g3_h3,
            evals_g4_h4_g5_h5,
            eval_q1,
            evals_t_f2_q2_n,
            evals_val_upper_lower_a_b_f1,
            evals_f1,
            eval_l,
            proofs_wit_upper_r_polys,
            proof_g1_h1,
            proof_g2_h2,
            proof_g3_h3,
            proof_g4_h4_g5_h5,
            proof_q1,
            proof_t_f2_q2_n,
            proof_val_upper_lower_a_b_f1,
            proof_f1,
            proof_l, 
        } = proof;

        let slice: &[P::G1] = &coms_wit_polys;
        <Transcript as ProofTranscript<P>>::append_points(transcript, b"v_and_u1", slice);
        let v = <Transcript as ProofTranscript<P>>::challenge_scalar(transcript, b"rlc");
        let u1 = <Transcript as ProofTranscript<P>>::challenge_scalar(transcript, b"random_ldt_padding");
        let mut coms = coms_upper_a.clone();
        coms.extend(coms_g1_h1);
        coms.push(coms_t_f2_q2[0]);
        coms.push(coms_t_f2_q2[1]);
        let slice: &[P::G1] = &coms;
        <Transcript as ProofTranscript<P>>::append_points(transcript, b"alpha_and_u2", slice);
        let alpha = <Transcript as ProofTranscript<P>>::challenge_scalar(transcript, b"random_evaluation_for_x");
        let u2 = <Transcript as ProofTranscript<P>>::challenge_scalar(transcript, b"random_ldt_padding");
        let gamma = <Transcript as ProofTranscript<P>>::challenge_scalar(transcript, b"batch_kzg");
        let mut coms = coms_g2_h2.clone();
        coms.extend(coms_upper_b);
        coms.push(coms_t_f2_q2[2]);
        let slice: &[P::G1] = &coms;
        <Transcript as ProofTranscript<P>>::append_points(transcript, b"beta", slice);
        let beta = <Transcript as ProofTranscript<P>>::challenge_scalar(transcript, b"random_evaluation_for_y");
        let mut coms = coms_f1.clone();
        let coms_f2 = coms_t_f2_q2[3..12].to_vec();
        coms.extend(&coms_f2);
        let slice: &[P::G1] = &coms;
        <Transcript as ProofTranscript<P>>::append_points(transcript, b"u3", slice);
        let w = <Transcript as ProofTranscript<P>>::challenge_scalar(transcript, b"rlc");
        let u3 = <Transcript as ProofTranscript<P>>::challenge_scalar(transcript, b"random_ldt_padding");
        let slice: &[P::G1] = &coms_g3_h3;
        <Transcript as ProofTranscript<P>>::append_points(transcript, b"delta_u4", slice);
        let delta = <Transcript as ProofTranscript<P>>::challenge_scalar(transcript, b"random_evaluation_for_x");
        let u4 = <Transcript as ProofTranscript<P>>::challenge_scalar(transcript, b"random_ldt_padding");
        let slice: &[P::G1] = &coms_g4_h4_g5_h5;
        <Transcript as ProofTranscript<P>>::append_points(transcript, b"zeta", slice);
        let zeta = <Transcript as ProofTranscript<P>>::challenge_scalar(transcript, b"random_evaluation_for_y");

        <Transcript as ProofTranscript<P>>::append_point(transcript, b"combined_polynomial_x_beta", &proofs_wit_upper_r_polys.0);
        let eta = <Transcript as ProofTranscript<P>>::challenge_scalar(
        transcript, b"random_evaluate_point");
        let mut slice_vector: Vec<P::ScalarField> = proofs_wit_upper_r_polys.1.clone();
        slice_vector.push(proofs_wit_upper_r_polys.2.clone());
        let slice: &[P::ScalarField] = &slice_vector;
        <Transcript as ProofTranscript<P>>::append_scalars(transcript, b"combined_polynomial_x_beta", slice);
        let theta = <Transcript as ProofTranscript<P>>::challenge_scalar(
        transcript, b"batch_kzg_rlc_challenge");

        // Verify all commitments
        let (check_commitments, check_openings) = rayon::join(
            || {
            // let time = Instant::now();
            let ((check2, check3, check4, check5), (check6, check8),
                (check7, check9, check10, check12)) = par_join_3!(
                || par_join_4!(
                    || BatchKZG::<P>::verify(&uni_v_srs_for_x, &coms_g1_h1, &alpha, &evals_g1_h1, &proof_g1_h1, &gamma).unwrap(),
                    || BatchKZG::<P>::verify(&uni_v_srs_for_y, &coms_g2_h2, &beta, &evals_g2_h2, &proof_g2_h2, &gamma).unwrap(), 
                    || BatchKZG::<P>::verify(&uni_m_v_srs_for_x, &coms_g3_h3, &delta, &evals_g3_h3, &proof_g3_h3, &gamma).unwrap(),
                    || BatchKZG::<P>::verify(&uni_v_srs_for_y, &coms_g4_h4_g5_h5, &zeta, &evals_g4_h4_g5_h5, &proof_g4_h4_g5_h5, &gamma).unwrap()
                ),
                || rayon::join(
                    || {
                        let evals_bivariate = vec![vec![evals_wit_upper_r_polys[0]],
                            vec![evals_wit_upper_r_polys[1], evals_wit_upper_r_polys[2]],
                            vec![evals_wit_upper_r_polys[3], evals_wit_upper_r_polys[4], evals_wit_upper_r_polys[5]],
                            vec![evals_wit_upper_r_polys[6]],
                            vec![evals_wit_upper_r_polys[7]]];
                        let x_points = vec![vec![alpha], 
                            vec![*r * alpha, *r],
                            vec![alpha, r.inverse().unwrap(), P::ScalarField::zero()],
                            vec![*r],
                            vec![r_pow_m]];
                        let mut coms_wit_and_upper_r_polys = coms_wit_polys.clone();
                        coms_wit_and_upper_r_polys.push(com_upper_r.clone());
        
                        BivBatchKZG::<P>::verify_at_same_y_optimized(&v_srs, &coms_wit_and_upper_r_polys, &x_points, &beta, &evals_bivariate, &proofs_wit_upper_r_polys, &gamma, eta, theta).unwrap()
                    }, 
                    || {
                        let t_points = vec![P::ScalarField::one(), delta, x_domain.group_gen() * delta];
                        let f2_points = vec![P::ScalarField::zero(), delta];
                        let n_points = vec![delta];
                        let q2_points = vec![delta];
                        let points = vec![t_points.clone(), t_points.clone(), t_points,
                            f2_points.clone(), f2_points.clone(), f2_points.clone(),
                            f2_points.clone(), f2_points.clone(), f2_points.clone(),
                            f2_points.clone(), f2_points.clone(), f2_points,
                            q2_points ,
                            n_points.clone(), n_points.clone(), n_points.clone(), n_points.clone(), 
                            n_points.clone(), n_points.clone(), n_points.clone(), n_points.clone(), n_points];
                        let mut coms_t_f2_q2_n = coms_t_f2_q2.clone();
                        coms_t_f2_q2_n.extend(coms_n);
                        BatchKZG::<P>::verify_multiple_polys_and_points_no_repeat(&uni_v_srs_for_x, &coms_t_f2_q2_n, &points, &delta, &x_domain.group_gen(), &(evals_t_f2_q2_n.clone(), proof_t_f2_q2_n.clone()), &gamma, transcript).unwrap()
                    }
                ),
                || par_join_4!(
                    || {
                        let mut coms_val_upper_lower_f1 = coms_val.clone();
                        coms_val_upper_lower_f1.extend(&coms_upper_a.clone());
                        coms_val_upper_lower_f1.extend(&coms_upper_b.clone());
                        coms_val_upper_lower_f1.extend(&coms_lower_a_b.clone());
                        coms_val_upper_lower_f1.extend(&coms_f1.clone());
                        BivBatchKZG::<P>::verify(&m_v_srs, &coms_val_upper_lower_f1, &(delta, zeta), &evals_val_upper_lower_a_b_f1, &proof_val_upper_lower_a_b_f1, &gamma).unwrap()
                    }, 
                    || BivBatchKZG::<P>::verify(&m_v_srs, &coms_f1, &(P::ScalarField::zero(), P::ScalarField::zero()), &evals_f1, &proof_f1, &gamma).unwrap(), 
                    || BivBatchKZG::<P>::verify(&v_srs, &vec![com_l.clone()], &(beta, zeta), &eval_l, &proof_l, &gamma).unwrap(), 
                    || KZG::<P>::verify(&uni_m_v_srs_for_x, &com_q1, &delta, &eval_q1, &proof_q1).unwrap()
                )
            );

            // check the validity of g1 h1, g2, h2
            assert!(check2);
            assert!(check3);
            assert!(check4);
            assert!(check5);
            assert!(check6);
            assert!(check7);
            assert!(check8);
            assert!(check9);
            assert!(check10);
            assert!(check12);
            // println!("Verifier commitment verification: {:?}", time.elapsed());
            true
        }, || {
            // let time = Instant::now();
            let z_h_eval_x = x_domain.evaluate_vanishing_polynomial(alpha);
            let (eval_pa_alpha_beta, eval_pb_alpha_beta, eval_pc_alpha_beta, eval_r_beta) = 
                (evals_p_alpha_beta[0], evals_p_alpha_beta[1], evals_p_alpha_beta[2], evals_wit_upper_r_polys[7]);

            let (f1, f2, f3, f4): (P::ScalarField, P::ScalarField, P::ScalarField, P::ScalarField) = (
                eval_pa_alpha_beta * evals_wit_upper_r_polys[0] - eval_r_beta * evals_wit_upper_r_polys[2],
                eval_pb_alpha_beta * evals_wit_upper_r_polys[0] - eval_r_beta * (evals_wit_upper_r_polys[4] * r_pow_m + evals_wit_upper_r_polys[5] * (P::ScalarField::one() - r_pow_m)),
                eval_pc_alpha_beta * evals_wit_upper_r_polys[0] - eval_r_beta * evals_wit_upper_r_polys[6],
                (evals_wit_upper_r_polys[1] * evals_wit_upper_r_polys[3] - evals_wit_upper_r_polys[6]) * eval_r_beta
            );

            let (left_hand, right_hand) = rayon::join(
                || {
                    let eval_rlc = linear_combination_field::<P>(&vec![f1, f2, f3, f4], &v);
                    let left_hand = (beta - u2) * (alpha - u1) * eval_rlc;
                    left_hand
                },
                || {
                    let t2 = (alpha * evals_g1_h1[0] + (alpha - u1) * z_h_eval_x * evals_g1_h1[1]) / y_domain.size_as_field_element();
                    let right_hand = beta * evals_g2_h2[0] + (beta - u2) * t2 + (beta - u2) * y_domain.evaluate_vanishing_polynomial(beta) * (evals_g2_h2[1] + beta.pow([l as u64]) * evals_g2_h2[2]);
                    right_hand
            });

            let check1 = left_hand == right_hand;
            assert!(check1);

            // evaluation check of f_pa(alpha, beta), f_pb(alpha, beta), f_pc(alpha, beta)
            let z_m_prime_eval_delta = m_domain.evaluate_vanishing_polynomial(delta);
            let delta_minus_u3 = delta - u3;
            let eval_rlc = linear_combination_field::<P>(evals_p_alpha_beta, &w);
            let eval_h = evals_g3_h3[1] + delta.pow([m_prime as u64]) * evals_g3_h3[2] + delta.pow([2 * m_prime as u64]) * evals_g3_h3[3];
            let t4 = delta * evals_g3_h3[0] + delta_minus_u3 * eval_rlc / m_domain.size_as_field_element() + 
                    delta_minus_u3 * z_m_prime_eval_delta * eval_h;
            
            let zeta_minus_u4 = zeta - u4;
            let right_hand = zeta * evals_g4_h4_g5_h5[0] + zeta_minus_u4 * t4 / y_domain.size_as_field_element() +
                zeta_minus_u4 * y_domain.evaluate_vanishing_polynomial(zeta) * 
                (evals_g4_h4_g5_h5[1] + zeta.pow([l as u64]) * evals_g4_h4_g5_h5[2] + 
                zeta.pow([2 * l as u64]) * evals_g4_h4_g5_h5[3] + zeta.pow([3 * l as u64]) * evals_g4_h4_g5_h5[4]);
            // compute left_hand
            let (f1, f2, f3) = (
                evals_val_upper_lower_a_b_f1[0] * evals_val_upper_lower_a_b_f1[3] * evals_val_upper_lower_a_b_f1[4] * evals_val_upper_lower_a_b_f1[9],
                evals_val_upper_lower_a_b_f1[1] * evals_val_upper_lower_a_b_f1[5] * evals_val_upper_lower_a_b_f1[6] * evals_val_upper_lower_a_b_f1[10],
                evals_val_upper_lower_a_b_f1[2] * evals_val_upper_lower_a_b_f1[7] * evals_val_upper_lower_a_b_f1[8] * evals_val_upper_lower_a_b_f1[11]
            );
            let eval_rlc = linear_combination_field::<P>(&vec![f1, f2, f3], &w);
            let left_hand = eval_rlc * eval_l[0] * zeta_minus_u4 * delta_minus_u3;
            let check11 = left_hand == right_hand;
            assert!(check11);

            // verify lookup evaluation validity
            // check T's evaluation validity
            // T_col
            let evals_t_col = evals_t_f2_q2_n[2].clone();
            let l_h_m_minums_1 = evaluate_one_lagrange::<P>(m-1, &x_domain, &delta);
            assert!(evals_t_col[0] == P::ScalarField::one());
            assert!(evals_t_col[2] == alpha * evals_t_col[1] + l_h_m_minums_1 * (P::ScalarField::one() - alpha.pow([m as u64])));
            // T_row_low
            let evals_t_row_low = evals_t_f2_q2_n[0].clone();
            assert!(evals_t_row_low[0] == P::ScalarField::one());
            assert!(evals_t_row_low[2] == *r * evals_t_row_low[1] + l_h_m_minums_1 * (P::ScalarField::one() - r.pow([m as u64])));
            // T_row_high
            let evals_t_row_high = evals_t_f2_q2_n[1].clone();
            assert_eq!(evals_t_row_high[0], P::ScalarField::one());
            let power = ((m * l) as f64).sqrt().floor() as usize;
            let r_sqrt = r.pow([power as u64]);
            assert!(evals_t_row_high[2] == r_sqrt * evals_t_row_high[1] + l_h_m_minums_1 * (P::ScalarField::one() - r_sqrt.pow([m as u64])));

            let left_evals = (0..9)
                .map(|i| evals_val_upper_lower_a_b_f1[21 + i] * (gamma + beta * evals_val_upper_lower_a_b_f1[12 + i] + evals_val_upper_lower_a_b_f1[3 + i]) - P::ScalarField::one())
                .collect::<Vec<_>>();
            let factor = zeta - u4;
            let left_hand = linear_combination_field::<P>(&left_evals, &v) * factor;
            let sum = *eval_q1 * m_domain.evaluate_vanishing_polynomial(delta) * factor / y_domain.size_as_field_element();
            let right_hand = zeta * evals_g4_h4_g5_h5[5] + sum + y_domain.evaluate_vanishing_polynomial(zeta) * factor * evals_g4_h4_g5_h5[6];
            assert_eq!(left_hand, right_hand);

            // check f2 evaluation validity
            let constant = gamma + beta * delta;
            let right_eval_1 = evals_t_f2_q2_n[3][1] * (constant + evals_t_f2_q2_n[0][1]) - evals_t_f2_q2_n[13][0];
            let right_eval_2 = evals_t_f2_q2_n[4][1] * (constant + evals_t_f2_q2_n[1][1]) - evals_t_f2_q2_n[14][0];
            let right_eval_3 = evals_t_f2_q2_n[5][1] * (constant + evals_t_f2_q2_n[0][1]) - evals_t_f2_q2_n[15][0];
            let right_eval_4 = evals_t_f2_q2_n[6][1] * (constant + evals_t_f2_q2_n[1][1]) - evals_t_f2_q2_n[16][0];
            let right_eval_5 = evals_t_f2_q2_n[7][1] * (constant + evals_t_f2_q2_n[0][1]) - evals_t_f2_q2_n[17][0];
            let right_eval_6 = evals_t_f2_q2_n[8][1] * (constant + evals_t_f2_q2_n[1][1]) - evals_t_f2_q2_n[18][0];
            let right_eval_7 = evals_t_f2_q2_n[9][1] * (constant + evals_t_f2_q2_n[2][1]) - evals_t_f2_q2_n[19][0];
            let right_eval_8 = evals_t_f2_q2_n[10][1] * (constant + evals_t_f2_q2_n[2][1]) - evals_t_f2_q2_n[20][0];
            let right_eval_9 = evals_t_f2_q2_n[11][1] * (constant + evals_t_f2_q2_n[2][1])- evals_t_f2_q2_n[21][0];
            let right_evals = vec![right_eval_1, right_eval_2, right_eval_3, right_eval_4, 
                right_eval_5, right_eval_6, right_eval_7, right_eval_8, right_eval_9];
            let right_eval_rlc = linear_combination_field::<P>(&right_evals, &v);
            let left = evals_t_f2_q2_n[12][0];
            assert!(right_eval_rlc == left * x_domain.evaluate_vanishing_polynomial(delta));

            //check f1 f2 relation
            let factor = m_domain.size_as_field_element() * y_domain.size_as_field_element() / x_domain.size_as_field_element();
            assert!(evals_f1[0] * factor == evals_t_f2_q2_n[3][0]);
            assert_eq!(evals_f1[1] * factor, evals_t_f2_q2_n[4][0]);
            assert_eq!(evals_f1[3] * factor, evals_t_f2_q2_n[6][0]);
            assert_eq!(evals_f1[4] * factor, evals_t_f2_q2_n[7][0]);
            assert_eq!(evals_f1[5] * factor, evals_t_f2_q2_n[8][0]);
            assert_eq!(evals_f1[6] * factor, evals_t_f2_q2_n[9][0]);
            assert_eq!(evals_f1[7] * factor, evals_t_f2_q2_n[10][0]);
            assert_eq!(evals_f1[8] * factor, evals_t_f2_q2_n[11][0]);
            true
        });

        assert!(check_commitments && check_openings);
        true
    }

    pub fn get_proof_size (
        proof: &SNARKProofLog<P>
    ) -> usize {
        let field_size = size_of_val(&P::ScalarField::one());
        let group_size = size_of_val(&P::G1::zero());

        let proof_len_wit_upper_r_polys = (proof.proofs_wit_upper_r_polys.1.len() + 1) * field_size + 4 * group_size;

        let proof_len_groups = group_size * (
            proof.coms_wit_polys.len() +
            proof.coms_upper_a.len() +
            proof.coms_g1_h1.len() +
            proof.coms_upper_b.len() +
            proof.coms_g2_h2.len() +
            proof.coms_f1.len() +
            proof.coms_g3_h3.len() + 
            proof.coms_g4_h4_g5_h5.len() +
            1 +
            proof.coms_t_f2_q2.len() +
            13
        );
        let proof_len_fields = field_size * (
            proof.evals_wit_upper_r_polys.len() +
            proof.evals_p_alpha_beta.len() +
            proof.evals_g1_h1.len() +
            proof.evals_g2_h2.len() + 
            proof.evals_g3_h3.len() +
            proof.evals_g4_h4_g5_h5.len() +
            1 +
            proof.evals_t_f2_q2_n[0].len() * 3 +
            proof.evals_t_f2_q2_n[3].len() * 9 + 
            1 + 9 +
            proof.evals_val_upper_lower_a_b_f1.len() + 
            proof.evals_f1.len() +
            proof.eval_l.len()
        );
        proof_len_fields + proof_len_groups + proof_len_wit_upper_r_polys
    }

}


